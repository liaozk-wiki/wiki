---
layout: post
title: å›¾
---


å›¾

<br>
ç»ˆäºæ¥åˆ°æœ€åä¸¤ç« äº†ï¼Œæ²¡æœ‰é‚£ä¹ˆå¤šçš„æ„ä¹‰å¯è¨€ï¼Œè¡ŒåŠ¨ï¼è¿˜æ˜¯è¡ŒåŠ¨ï¼å‰è¿›ï¼Œç»§ç»­å‰è¿›ï¼
<br>
åœ¨å­¦ä¹ ä¹‹å‰ï¼Œä¸è¦æŠŠå›¾æƒ³çš„éå¸¸å¤æ‚ï¼Œä»–ç¡®å®æ˜¯ä¸€ä¸ªç›¸å¯¹å°çš„è‡ªæˆä¸€ä½“çš„é¢†åŸŸï¼Œåœ¨æŒ‘æˆ˜è¿‡äºŒå‰æœç´¢æ ‘ï¼Œå¯¹é€’å½’ï¼Œå¾ªç¯ç­‰æœ‰äº†ä¸€å®šç»ƒä¹ ä¹‹åï¼Œå›¾ä¸å†æ˜¯ä¸€ä¸ªè®©äººä»°æœ›éš¾ä»¥æ”€ç™»çš„é«˜å³°ï¼Œæ‘¸ä¸€æ‘¸å±±è„šæ˜¯è‚¯å®šå¯ä»¥åšåˆ°çš„ã€‚äºŒå‰æ ‘ç®—æ˜¯ç‰¹æ®Šçš„å›¾ï¼Œå›¾æ¯”äºŒå‰æ ‘æ‰€æè¿°çš„æ›´é€šç”¨ï¼Œä¹Ÿæ›´å¹¿æ³›ã€‚åœ¨å¯¹ç‰¹ä¾‹è¿›è¡Œäº†ç ”ç©¶åé€€å›åˆ°æ›´ä½ä¸€çº§çš„æŠ½è±¡æ—¶ä¸åº”è¯¥æ„Ÿåˆ°ææƒ§ï¼Œæ›´åº”æ˜¯ä¸€ç§å¤„å¤„éƒ½æ„Ÿåˆ°ç†Ÿæ‚‰ï¼Œæ›¾ç»æ¥è¿‡çš„æ„Ÿè§‰ã€‚
<br>
åœ¨è¿™ä¸€ç« çš„å­¦ä¹ ä¸­ï¼Œç»“æ„è¿˜æ˜¯åŸºæœ¬åŸºäºã€Šç®—æ³•ã€‹çš„å®‰æ’ï¼Œå…ˆç»™å‡ºå›¾åœ¨æ•°å­¦ä¸­çš„ä¸€äº›å®šä¹‰ï¼Œå†ç»™å‡ºé€šç”¨çš„å›¾æ•°æ®ç»“æ„ï¼Œæœ€ååˆ™æ˜¯å®Œå…¨æŒ‰ç…§ä¹¦ä¸­å®‰æ’ä»æ— å‘å›¾ã€æœ‰å‘å›¾ã€ä¸€æ­¥æ­¥èµ°åˆ°åŠ æƒå›¾ã€åŠ æƒæœ‰å‘å›¾ã€‚
<br>
20240103-18ï¼š56ï¼šæ„Ÿå†’å¾ˆç—›è‹¦ï¼Œé¼»å¡äº†å¾ˆä¹…ã€‚
<br>
åœ¨æ·±å…¥å›¾åŠç›¸å…³çš„ç®—æ³•ä¹‹å‰ï¼Œéå¸¸æœ‰å¿…è¦ä»‹ç»ä¸€ç‚¹ç¦»æ•£æ•°å­¦ä¸­çš„å›¾è®ºï¼š
<br>

# å›¾è®º

<br>
å¯¹ä¸€é—¨ä¸¥è‚ƒçš„çŸ¥è¯†ï¼Œè¿›è¡Œæ¸¸é¾™æˆæ°´èˆ¬çš„æ¢ç´¢ï¼Œæ˜¯å¦æ˜¯ä¸€ç§æµªè´¹æ—¶é—´å‘¢ï¼Ÿå¯¹äº21å¹´èŠ±äº†ä¸€ä¸ªå¤šæœˆæ—¶é—´ç®€å•çš„è¿‡äº†ç¦»æ•£æ•°å­¦éšå³ä¾¿å¿˜çš„ä¸€ç‚¹ä¸å‰©çš„æˆ‘ï¼Œæˆ‘å€¾å‘äºè‚¯å®šçš„å›ç­”ã€‚
<br>
å›¾ï¼šç‚¹é›†åˆ+è¾¹é›†åˆ+è¾¹é›†åˆåˆ°ç‚¹é›†åˆçš„å‡½æ•°ã€‚

```python
V = ['A', 'B', 'C']
E = ['e1', 'e2', 'e3']
f = {
    'e1': ('A', 'B'),
    'e2': ('B', 'C'),
    'e3': ('A', 'C')
}
```



<br>
é‚»æ¥ç‚¹ï¼šåŒä¸€æ¡è¾¹ä¸Šçš„ä¸¤ä¸ªç»“ç‚¹ã€‚
<br>
å­¤ç«‹ç»“ç‚¹ï¼šä¸ä¸ä»»ä½•ç»“ç‚¹å‘é¢†æ¥çš„ç»“ç‚¹ã€‚
<br>
é›¶å›¾ï¼šä»…ç”±å­¤ç«‹ç»“ç‚¹æ„æˆçš„å›¾ã€‚
<br>
å¹³å‡¡å›¾ï¼šä»…ç”±ä¸€ä¸ªå­¤ç«‹ç»“ç‚¹æ„æˆã€‚
<br>
é‚»æ¥è¾¹ï¼šåŒä¸€ä¸ªç»“ç‚¹ä¸Šçš„ä¸¤æ¡è¾¹ã€‚
<br>
è‡ªå›è·¯/ç¯ï¼šå…³è”äºåŒä¸€ç»“ç‚¹çš„ä¸€æ¡è¾¹ã€‚ç¯çš„æ–¹å‘æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚
<br>
ç»“ç‚¹åº¦æ•°ï¼šç»“ç‚¹å…³è”çš„è¾¹çš„æ•°é‡ã€‚
<br>
ç»“ç‚¹åº¦æ•°çš„æ€»å’Œ=è¾¹æ•°*2.ç”±æ­¤å¯ä»¥æ¨å‡ºï¼šæ¯ä¸€ä¸ªå›¾ä¸­ï¼Œåº¦æ•°ä¸ºå¥‡æ•°çš„ç»“ç‚¹ä¸ªæ•°å¿…ç„¶æ˜¯å¶æ•°ä¸ªã€‚
<br>
å…¥åº¦/å‡ºåº¦ï¼šæœ‰å‘å›¾ä¸­çš„ã€‚
<br>
ç®€å•å›¾ï¼šä¸å«æœ‰å¹³è¡Œè¾¹&ç¯çš„å›¾ã€‚
<br>
è¡¥å›¾ï¼š
<br>
åŒæ„ï¼š
<br>
è·¯ï¼š
<br>
è¿¹ï¼šè·¯ä¸­è¾¹å‡ä¸åŒ
<br>
é€šè·¯ï¼šè·¯ä¸­æ‰€æœ‰ç»“ç‚¹å‡ä¸åŒ
<br>
è¿é€šå›¾ï¼šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†æ”¯
<br>
ç‚¹å‰²é›†ï¼šåˆ é™¤å…¶ä¸­æ‰€æœ‰ç»“ç‚¹åå¾—åˆ°çš„å­å›¾ä¸å†æ˜¯è¿é€šå›¾ï¼Œä½†åˆ é™¤å…¶ä»»æ„çœŸå­é›†ï¼Œè¿˜æ˜¯è¿é€šå›¾ã€‚
<br>
è¾¹å‰²é›†ï¼šåŒä¸Š
<br>
å‰²ç‚¹ï¼šè¯¥ç‚¹æ„æˆç‚¹å‰²é›†
<br>
å‰²è¾¹ï¼šåŒä¸Š
<br>
å…³äºå›¾è®ºè¿˜æœ‰è®¸å¤šçš„å®šä¹‰ï¼Œä¸è¿‡å®Œæˆæ¯”å®Œç¾æ›´é‡è¦...
<br>

# æ— å‘å›¾

<br>
æœ€ç®€å•çš„å›¾å®šä¹‰ï¼šé¡¶ç‚¹ & å°†é¡¶ç‚¹ç›¸è¿çš„è¾¹ æ‰€ç»„æˆçš„ä¸œè¥¿ã€‚ä¸æ ‘çš„å®šä¹‰ç›¸æ¯”å°‘äº†ï¼šä¸¤ç‚¹ä¹‹é—´åªæœ‰å”¯ä¸€çš„ä¸€æ¡è·¯å¾„çš„é™åˆ¶ã€‚
<br>
è¾¹ä¾é™„äºé¡¶ç‚¹
<br>
é¡¶ç‚¹çš„åº¦æ•°
<br>
å­å›¾ï¼šè¾¹çš„å­é›†
<br>
è·¯å¾„
<br>
ç®€å•è·¯å¾„
<br>
ç¯
<br>
ç®€å•ç¯
<br>
è¿é€šå›¾ï¼šä»»æ„é¡¶ç‚¹éƒ½å­˜åœ¨ä¸€æ¡è·¯å¾„åˆ°è¾¾å¦ä¸€ä»»æ„é¡¶ç‚¹ã€‚è¿é€šå›¾å¯ä»¥ä¸€æŠŠæèµ·æ¥ï¼Œéè¿é€šå›¾åˆ™æ˜¯ç”±å¤šä¸ªè¿é€šåˆ†é‡ç»„æˆã€‚
<br>
å¯†åº¦
<br>
æ— å‘å›¾çš„æŠ½è±¡apiï¼š

```java
package define;

public interface IGraph {
  
    int V();

    int E();

    void addEdge(int v, int w);

    Iterable<Integer> adj(int v);

}
```

<br>
æŠ½è±¡ç±»ï¼š

````java
package define;

public abstract class AbstructUndirectedGraph implements IGraph {

}
````

<br>
å®ç°ï¼š
<br>
ä¸€èˆ¬æœ‰å¦‚ä¸‹ä¸‰ç§æ–¹å¼ï¼š
<br>
1.é‚»æ¥çŸ©é˜µï¼Œç”¨ä¸€ä¸ªv*vçš„å¸ƒå°”çŸ©é˜µï¼Œä½†ç‚¹æ•°å¤ªå¤šï¼ŒåŠå…¶è€—è´¹æ—¶é—´ã€‚
<br>
2.è¾¹çš„æ•°ç»„ï¼Œç”¨ä¸€ä¸ªç±»è¡¨ç¤ºä¸€æ¡è¾¹ï¼Œåœ¨ç”¨è¾¹çš„æ•°ç»„è¡¨ç¤ºå›¾ï¼Œadjéœ€è¦éå†æ‰€æœ‰è¾¹ã€‚
<br>
3.é‚»æ¥è¡¨æ•°ç»„ï¼Œä»¥é¡¶ç‚¹ä¸ºç´¢å¼•çš„æ•°ç»„ï¼Œæ•°ç»„ä¸­å­˜æ”¾è¯¥ç‚¹æ‰€æœ‰çš„é‚»æ¥ç‚¹ã€‚ï¼ˆæ•°ç»„çš„ç´¢å¼•è¡¨ç¤ºç‚¹ï¼Œå†…å®¹ä¸ºä¸ä¹‹ç›¸é‚»çš„ç‚¹çš„listï¼ˆä¸‹ä¾‹ä¸­çš„bagï¼‰ï¼‰
<br>
ä¹¦ä¸­é‡‡ç”¨ç¬¬ä¸‰ç§æ–¹å¼ï¼Œso æœ¬æ–‡äº¦å¦‚æ­¤äº†ã€‚åŸå› ï¼Ÿåœ¨è¿›è¡Œæ·±å…¥ä¹‹å‰ï¼Œè¿˜æ˜¯å…ˆä¾è‘«èŠ¦ç”»ç“¢ã€‚

```java
package define;

import define.impl.LinkBag;
import edu.princeton.cs.algs4.In;

public class Graph extends AbstructUndirectedGraph{

    private final int V;//å¤šå°‘ä¸ªç‚¹
    private int E;
    private Bag<Integer>[] adj;

    public Graph(int V) {
        this.V = V;
        this.E = 0;
        this.adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v  < V; v++) {
            this.adj[v] = new LinkBag<>();
        }
    }

    public Graph(In in) {
        this(in.readInt());
        int E = in.readInt();
        for (int i = 0; i < E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            this.addEdge(v, w);
        }
    }

    @Override
    public int V() {
        return this.V;
    }

    @Override
    public int E() {
        return this.E;
    }

    @Override
    public void addEdge(int v, int w) {
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }

    @Override
    public Iterable<Integer> adj(int v) {
        return adj[v];
    }
}
```

<br>
åœ¨è¿›è¡Œäº†ä¸€äº›æ¦‚å¿µä¸æ•°æ®ç»“æ„çš„å®šä¹‰ä¹‹åï¼Œä¸‹é¢å‡†å¤‡å¼€å§‹å›¾çš„ç›¸å…³ç®—æ³•ã€‚
<br>
å›¾çš„è®¸å¤šæ€§è´¨ä¸è·¯å¾„æœ‰å…³ï¼Œä¸€ä¸ªé€šç”¨çš„æŠ½è±¡ä¾¿æ˜¯ï¼Œæ²¿ç€è¾¹ä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹ã€‚
<br>

## æ·±åº¦ä¼˜å…ˆæœç´¢

<br>
åœ¨å¯¹é€’å½’æœ‰äº†ä¸€å®šç¨‹åº¦çš„äº†è§£åï¼Œæ·±åº¦ä¼˜å…ˆç®—æ³•åº”è¯¥æ˜¯ä¿¡æ‰‹æ‹ˆæ¥ã€‚
<br>

1. ä»ä¸€ä¸ªç‚¹å¼€å§‹ï¼Œé€‰æ‹©ä¸€ä¸ªæ²¡æœ‰éå†è¿‡çš„ç‚¹ã€‚
2. æ¯éå†ä¸€ä¸ªç‚¹å°±æ‰“ä¸Šæ ‡è®°ã€‚
3. å¦‚æœç‚¹å·²ç»éå†è¿‡äº†å°±é€€å›åˆ°ä¸Šä¸€ä¸ªç‚¹ã€‚
4. å¦‚æœä¸Šä¸€ä¸ªç‚¹çš„æ‰€æœ‰ç›¸é‚»ç‚¹éƒ½éå†è¿‡äº†ï¼Œå°±é€€å›åˆ°ä¸Šä¸€ä¸ªç‚¹ã€‚



<br>

apiï¼š

```java
package algorithm.api;

public interface ISearch {
    
    boolean marked(int v);
    
    int count();
}
```

<br>
å®ç°ï¼š

```java
package algorithm;

import define.Graph;

public class DepthFristSearch {
    private boolean[] marked;
    private int count;

    public DepthFristSearch(Graph G, int s) {
        marked = new boolean[G.V()];
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    public boolean marked(int w) {
        return marked[w];
    }
    
    public int count() {
        return count;
    }
}
```

<br>
æœç´¢ä¸€å¹…å›¾ï¼Œåªéœ€è¦ä¸€ä¸ªé€’å½’æ–¹æ³•éå†æ‰€æœ‰é¡¶ç‚¹ï¼š

1. è®¿é—®è¿‡çš„ç‚¹æ‰“ä¸Šæ ‡è®°ã€‚
2. é€’å½’è®¿é—®æ‰€æœ‰æ²¡æœ‰è¢«æ ‡è®°è¿‡ç‚¹ã€‚



æ— å‘å›¾ä¸­çš„æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œæ¯æ¡è¾¹éƒ½ä¼šè¢«è®¿é—®ä¸¤æ¬¡ï¼Œaåˆ°bï¼Œè¿™æ˜¯ç¬¬ä¸€æ¬¡ï¼Œbåˆ°aè¿™æ˜¯ç¬¬äºŒæ¬¡ï¼ˆaæ­¤æ—¶å·²è¢«æ ‡è®°ï¼‰ã€‚
<br>
æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œå¯ä»¥å¤„ç†ï¼š

1. è¿é€šæ€§ï¼šç»™å®šçš„ä¸¤ä¸ªç‚¹ä¹‹é—´æ˜¯å¦æ˜¯è¿é€šçš„ï¼Ÿå›¾å­˜åœ¨å¤šå°‘ä¸ªè¿é€šå­å›¾ï¼Ÿ
2. å•ç‚¹è·¯å¾„ï¼šåœ¨ç»™å®šçš„ä¸€å¹…å›¾ï¼Œä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ˜¯å¦å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Ÿ



æ¥ä¸‹æ¥ä»‹ç»ï¼Œæ·±åº¦ä¼˜å…ˆç®—æ³•ä¸­çš„è·¯å¾„æŸ¥æ‰¾é—®é¢˜ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œé¢å…³äºè·¯å¾„çš„è§£å†³æŠ€å·§ä¼šç”¨åœ¨åé¢è¯¸å¤šæ›´åŠ å¤æ‚ï¼Œæ›´åŠ å¼ºå¤§çš„ç®—æ³•ä¸­ã€‚
<br>
apiï¼š

```java
package algorithm.api;

public interface IPaths {

    /** æ˜¯å¦å­˜åœ¨såˆ°vçš„è·¯å¾„ */
    boolean hasPathTo(int v);

    /** såˆ°vçš„è·¯å¾„ï¼Œå¦‚æœä¸å­˜åœ¨å°±è¿”å›null */
    Iterable<Integer> pathTo(int v);
}
```

<br>
å®ç°ï¼š

```java
package algorithm;

import algorithm.api.IPaths;
import define.Graph;
import define.Stack;
import define.impl.ListStack;

public class DepthFristPaths implements IPaths {
    
    private boolean[] marked;
    
    private int[] edgeTo;
    
    private final int s;
    
    public DepthFristPaths(Graph g, int s) {
        marked = new boolean[g.V()];
        edgeTo = new int[g.V()];
        this.s = s;
        dfs(g, s);
    }
    
    private void dfs(Graph g, int v) {
        marked[v] = true;
        for (int w : g.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(g, w);
            }
        }
    }
    
    @Override
    public boolean hasPathTo(int v) {
        return marked[v];
    }

    @Override
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new ListStack<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

<br>
å¯¹äºedgeToæ•°ç»„è€Œè¨€ï¼Œé‡Œé¢çš„è¾¹æ„é€ å‡ºäº†ä¸€æ£µä»¥sä½œä¸ºrootçš„äºŒå‰æ ‘ã€‚
<br>

## å¹¿åº¦ä¼˜å…ˆæœç´¢

<br>
æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œè§£å†³äº†æ˜¯å¦å­˜åœ¨è¿é€š/è·¯å¾„çš„é—®é¢˜ï¼Œå€˜è‹¥è¦æ‰¾åˆ°æœ€çŸ­çš„è·¯å¾„ï¼Œåˆ™éœ€è¦å¹¿åº¦ä¼˜å…ˆç®—æ³•ã€‚
<br>
æ·±åº¦ä¼˜å…ˆæœç´¢åœ¨ï¼Œè¿™ä¸ªé—®é¢˜ä¸Šæ²¡æœ‰ä»€ä¹ˆä½œä¸ºï¼Œå› ä¸ºå…¶éå†æ•´ä¸ªå›¾çš„é¡ºåºä¸æ‰¾å‡ºæœ€çŸ­è·¯å¾„çš„ç›®æ ‡æ²¡æœ‰ä»»ä½•è”ç³»ã€‚
<br>
å¦‚æœè¯´æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ä¸ªäººåœ¨èµ°è¿·å®«ï¼Œé‚£ä¹ˆå¹¿åº¦ä¼˜å…ˆæœç´¢åˆ™æ˜¯ä¸€ç¾¤äººåœ¨èµ°è¿·å®«ã€‚
<br>
å¹¿åº¦ä¼˜å…ˆæœç´¢çš„åŸºæœ¬æ€æƒ³ä¾¿æ˜¯ï¼š
<br>

1. ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ä¿å­˜ï¼Œå·²è¢«æ ‡è®°ä½†å…¶é¢†æ¥è¡¨è¿˜æœªè¢«æ£€æŸ¥è¿‡çš„é¡¶ç‚¹ã€‚
2. å–é˜Ÿåˆ—ä¸­ä¸‹ä¸€ä¸ªé¡¶ç‚¹vå¹¶æ ‡è®°ã€‚
3. å°†æ‰€æœ‰ä¸vç›¸é‚»å¹¶æœªè¢«æ ‡è®°çš„é¡¶ç‚¹åŠ å…¥é˜Ÿåˆ—ã€‚



æ·±åº¦ä¼˜å…ˆï¼Œéšå¼çš„ä½¿ç”¨äº†ä¸€ä¸ªå †ï¼ˆé€’å½’ï¼‰ï¼Œå¹¿åº¦åˆ™æ˜¯ç°å¼çš„ä½¿ç”¨äº†ä¸€ä¸ªé˜Ÿåˆ—ã€‚
<br>
api åŒæ·±åº¦æœç´¢ä¼˜å…ˆä¸€è‡´
<br>
å®ç°ï¼š

```java
package algorithm;

import algorithm.api.IPaths;
import define.Graph;
import define.Queue;
import define.Stack;
import define.impl.ListQueue;
import define.impl.ListStack;

public class BreadthFristPaths implements IPaths {
    
    private boolean[] marked;
    private int[] edgeTo;
    private final int s;
    
    public BreadthFristPaths(Graph g, int s) {
        marked = new boolean[g.V()];
        edgeTo = new int[g.V()];
        this.s = s;
        bfs(g, s);
    }
    
    private void bfs(Graph g, int s) {
        Queue<Integer> queue = new ListQueue<>();
        marked[s] = true;
        queue.enqueue(s);
        while (!queue.isEmpty()) {
            int v = queue.dequeue();
            for (int w : g.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.enqueue(w);
                }
            }
        }
    }
  
    @Override
    public boolean hasPathTo(int v) {
        return marked[v];
    }

    @Override
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new ListStack<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

<br>
æ·±åº¦ä¼˜å…ˆæœç´¢ä¸å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œéƒ½æ˜¯å›¾é€šç”¨çš„æœç´¢ç®—æ³•ï¼Œæœç´¢ä¸­ï¼Œæˆ‘ä»¬éƒ½ä¼šå°†èµ·ç‚¹å­˜å…¥æ•°æ®ç»“æ„ï¼Œç„¶åé‡å¤å¦‚ä¸‹æ­¥éª¤ï¼š
<br>

1. å–å…¶ä¸­çš„ä¸‹ä¸€ä¸ªé¡¶ç‚¹å¹¶æ ‡è®°ã€‚
2. å°†vçš„æ‰€æœ‰ç›¸é‚»è€Œåˆæœªè¢«æ ‡è®°çš„é¡¶ç‚¹åŠ å…¥æ•°æ®ç»“æ„ã€‚



ä¸¤ä¸ªç®—æ³•çš„ä¸åŒä¹‹å¤„åœ¨äºä»æ•°æ®ç»“æ„ä¸­è·å–ä¸‹ä¸€ä¸ªé¡¶ç‚¹çš„è§„åˆ™ï¼Œå¹¿åº¦ä¼˜å…ˆæ˜¯å–æœ€æ—©åŠ å…¥çš„ï¼Œæ·±åº¦ä¼˜å…ˆåˆ™æ˜¯å–æœ€æ™šåŠ å…¥çš„ï¼ˆé€’å½’éšå¼çš„åŒ…å«ä¸€ä¸ªstackï¼Œå¯ä»¥å°†dfsä¿®æ”¹ä¸ºä½¿ç”¨stackçš„å¾ªç¯ï¼‰ã€‚

```java
private void dfsWithStack(Graph g, int v) {
        Stack<Integer> stack = new ListStack<>();
        stack.push(v);
        marked[v] = true;
        while (!stack.isEmpty()) {
            int node = stack.pop();
            for (int w : g.adj(node)) {
                if (!marked[w]) {
                    edgeTo[w] = node;
                    marked[w] = true;
                    stack.push(w);
                }
            }
        }
    }
```

<br>

## è¿é€šåˆ†é‡

<br>
ç±»ä¼¼äºunionfindï¼Œå®ç°çš„æ€è·¯ä¹Ÿéå¸¸ç®€å•ï¼Œæˆ‘ä»¬ä»¥ä¸€ä¸ªç‚¹ä½œä¸ºèµ·ç‚¹ï¼Œå¼€å§‹åœ¨å›¾ä¸Šè¿›è¡Œæ·±åº¦æœç´¢ï¼Œå°†æ‰€æœ‰éå†è¿‡çš„ç‚¹æ‰“ä¸Šmarkæ ‡è®°ï¼ŒåŒæ—¶å°†idæ•°ç»„å‡è®¾ç½®ä¸ºcountï¼Œç„¶åå¯¹å‰©ä¸‹çš„æœªæ ‡è®°çš„ç‚¹é€ä¸€æ‰«æï¼Œè‡³å¤šv()æ¬¡å°±å¯ä»¥æ±‚å‡ºå›¾ä¸­æ‰€æœ‰çš„è¿é€šåˆ†é‡ã€‚
<br>
api:

```java
package algorithm.api;

public interface ICC {
    boolean connected(int v, int w);
    
    int count();
    
    int id(int v);
}
```

<br>
å®ç°ï¼š

```java
package algorithm;

import algorithm.api.ICC;
import define.Graph;

public class CC implements ICC {

    private boolean[] marked;
    private int[] id;
    private int count;

    public CC(Graph g) {
        marked = new boolean[g.V()];
        id = new int[g.V()];
        for (int s = 0; s < g.V(); s++) {
            if (!marked[s]) {
                dfs(g, s);
                count++;
            }
        }
    }

    private void dfs(Graph g, int s) {
        marked[s] = true;
        id[s] = count;
        for (int w : g.adj(s)) {
            if (!marked[w]) {
                dfs(g, w);
            }
        }
    }

    @Override
    public boolean connected(int v, int w) {
        return id[v] == id[w];
    }

    @Override
    public int count() {
        return count;
    }

    @Override
    public int id(int v) {
        return id[v];
    }
}
```

<br>
åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œä¸€ä»¶æœ‰æ„æ€çš„äº‹æƒ…æ¥äº†ï¼ŒunionFind ä¸ ä¸Šé¢çš„ccéƒ½æ˜¯å°†ä¸€å †çš„ç‚¹è¿›è¡Œåˆ†ç±»ï¼Œç›¸äº’è¿é€šçš„æ”¾åœ¨ä¸€èµ·ï¼Œä»åŠŸèƒ½é€»è¾‘ä¸Šè®²ï¼ŒäºŒè€…æ˜¯ä¸€è‡´çš„ï¼Œä½†äºŒè€…åŸºäºä¸åŒçš„æ•°æ®ç»“æ„ï¼Œå®ç°åŠŸèƒ½æœ‰è¿™ä¸åŒçš„ç®—æ³•ã€‚
<br>
åˆ©ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼Œè¿˜å¯ä»¥å¹²è®¸å¤šäº‹æƒ…ï¼š
<br>
1.ç¯é—®é¢˜ï¼šæ£€æµ‹æ˜¯å¦å­˜åœ¨ç¯
2.åŒè‰²é—®é¢˜ï¼šèƒ½å¦ç”¨ä¸¤ç§é¢œè‰²åŒºåˆ†å›¾
<br>
ç¯é—®é¢˜ï¼š

```java
package algorithm;

import define.Graph;

/**
 * ç¯é—®é¢˜ï¼Œå…¶å®å°±å˜å¾—éå¸¸ç®€å•äº†ï¼Œå³ç­‰ä»·äºï¼šåœ¨æ·±åº¦ä¼˜å…ˆçš„éå†ä¸­æ˜¯å¦éå†åˆ°èµ·ç‚¹ã€‚
 */
public class Cycle {
    private boolean[] marked;
    
    private boolean hasCycle;
    
    public Cycle(Graph g) {
        marked = new boolean[g.V()];
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i, i);   
            }
        }
    }
    
    private void dfs(Graph g, int i, int u) {
        marked[i] = true;
        for (int w : g.adj(i)) {
            if (!marked[w]) {
                dfs(g, w, i);
            } else if (w == u) {
                hasCycle = true;
                break;
            }
        }
    }
    
    public boolean hasCycle() {
        return hasCycle;
    }
}
```

<br>
äºŒè‰²é—®é¢˜ï¼š

```java
package algorithm;

import define.Graph;

/**
 * äºŒè‰²é—®é¢˜ï¼Œä¹¦ä¸Šè¯´ç­‰ä»·äºäºŒåˆ†å›¾ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢çš„è¿™ä¸ªç®—æ³•ç¨ä½œä¿®æ”¹å¯ä»¥æ‰¾äºŒåˆ†å›¾ã€‚
 * åŸºæœ¬é€»è¾‘ï¼š
 * éå†æ—¶ å°†å­èŠ‚ç‚¹ æ ‡è®°ä¸º ï¼çˆ¶èŠ‚ç‚¹
 * å¦‚æœé‡åˆ°å·²ç»éå†è¿‡çš„ç»“ç‚¹ï¼Œå°±åˆ¤æ–­ä¸‹é¢œè‰²æ˜¯å¦ä¸€è‡´ï¼Œä¸€è‡´åˆ™è¡¨ç¤ºä¸èƒ½å®ç°äºŒåˆ†
 */
public class TwoColor {
    private boolean[] marked;
    private boolean[] color;
    private boolean isTwoColorable = true;

    public TwoColor(Graph g) {
        marked = new boolean[g.V()];
        color = new boolean[g.V()];
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i);
            }
        }
    }

    private void dfs(Graph g, int i) {
        marked[i] = true;
        for (int w : g.adj(i)) {
            if (!marked[w]) {
                color[w] = !color[i];
                dfs(g, w);
            } else if (color[w] == color[i]) {
                isTwoColorable = false;
                break;
            }
        }
    }
    
    public boolean isBipartite() {
        return isTwoColorable;
    }
}
```

<br>

## ç¬¦å·å›¾

<br>
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå…³äºå›¾çš„ç›¸å…³æ•°æ®ç»“æ„ä¸ç®—æ³•å‡æ˜¯ç”¨æ•°å­—æ¥è¡¨ç¤ºç»“ç‚¹ï¼Œå¯å®é™…ä¸­é‡åˆ°çš„é—®é¢˜ï¼Œæ›´å¤šçš„éœ€è¦ç”¨å­—ç¬¦ä¸²æ¥è¡¨ç¤ºã€‚å¦‚ä½•å°†å­—ç¬¦ä¸²ä¸æˆ‘ä»¬å‰é¢æ‰€å­¦çš„è¿™äº›è”ç³»èµ·æ¥å‘¢ï¼Ÿè‡ªç„¶éœ€è¦å»ºç«‹ä¸€ç§æ˜ å°„å…³ç³»ï¼Œå…¶èƒŒåæ‰€è•´å«çš„æ€æƒ³ä¸å¯Œè±ªè¡¨&hashç­‰å®Œå…¨ä¸€è‡´ã€‚åœ¨è¿™ç§éœ€æ±‚ä¸‹ï¼Œç¬¦å·å›¾åº”è¿è€Œç”Ÿã€‚
<br>
api:

```java
package algorithm.api;

import define.Graph;

public interface ISymbolGraph {

    boolean contains(String key);
  
    int index(String key);

    String name(int v);

    Graph g();
  
}
```

<br>
å®ç°ï¼š

````java
package algorithm;

import algorithm.api.ISymbolGraph;
import define.Graph;
import define.SequentialSearchST;
import define.SimpleST;
import edu.princeton.cs.algs4.In;

/**
 * ç¬¦å·å›¾çš„å®ç°ä¸­
 * ä¸€ä¸ªç¬¦å·è¡¨ï¼Œç”¨æ¥ä¿å­˜ï¼Œå­—ç¬¦ä¸²ä¸æ•°å­—çš„æ˜ å°„
 * ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œå……å½“åå‘ç´¢å¼•ï¼Œç”¨æ¥ä¿å­˜æ•°å­—ä¸å­—ç¬¦ä¸²çš„æ˜ å°„
 * ä¸€ä¸ªæ•°å­—è¡¨ç¤ºç»“ç‚¹çš„å›¾
 */
public class SymbolGraph implements ISymbolGraph {
    private SimpleST<String, Integer> st;
    private String[] keys;
    private Graph g;

    public SymbolGraph(String stream, String sp) {
        st = new SequentialSearchST<>();
        In in = new In(stream);
        while (in.hasNextLine()) {
            String[] a = in.readLine().split(sp);

            for (int i = 0; i < a.length; i++) {
                if (!st.contains(a[i])) {
                    st.put(a[i], st.size());
                }
            }
        }
        
        
        keys = new String[st.size()];
        for (String name : st.keys()) {
            keys[st.get(name)] = name;
        }
        
        g = new Graph(st.size());
        in = new In(stream);
        while (in.hasNextLine()) {
            String[] a = in.readLine().split(sp);
            int v = st.get(a[0]);
            for (int i = 1; i < a.length; i++) {
                g.addEdge(v,st.get(a[i]));
            }
        }
    }

    @Override
    public boolean contains(String key) {
        return st.contains(key);
    }

    @Override
    public int index(String key) {
        return st.get(key);
    }

    @Override
    public String name(int v) {
        return keys[v];
    }

    @Override
    public Graph g() {
        return g;
    }
}
````

<br>

## é—´éš”çš„åº¦æ•°

<br>
é—´éš”çš„åº¦æ•°é—®é¢˜ï¼Œç±»ä¼¼äºå…­åº¦ç†è®ºï¼Œè¿™é‡Œå°±ä¸ç»™ä»£ç å®ä¾‹äº†ï¼ˆæˆ‘æ˜¯å¦‚æ­¤çš„æ‡’æƒ°ï¼Œä¹¦ä¸­æ²¡æœ‰çš„ï¼Œè‡ªå·±ç»ä¸æ„¿èŠ±æ—¶é—´æ¥æ€è€ƒï¼Œå¹¶ç”¨é‚£ä¸€å¥ å®Œæˆæ¯”å®Œç¾æ›´é‡è¦ æ¥ä½œä¸ºè‡ªèº«è¡ŒåŠ¨åŠ›ä¸è¶³çš„ä½è¯ï¼‰ã€‚
<br>

1. æ„é€ å›¾
2. å›¾ä¸­å¯»æ‰¾æœ€çŸ­è·¯å¾„ã€‚



# æœ‰å‘å›¾

<br>
20240107-16:23ï¼šåº”è¯¥æ­å–œè‡ªå·±ï¼Œç»ˆäºèµ°åˆ°äº†è¿™é‡Œï¼Œæˆ‘åº”è¯¥ä¼‘æ¯äºŒåæ¥åˆ†é’Ÿï¼Œç„¶åå°†æ¸ºèŒ«å¸Œæœ›å¯„æ‰˜äºæ¥ä¸‹æ¥çš„ä¸‰å°æ—¶å·¦å³ã€‚å–‚ï¼Œå–‚ï¼Œè¿™ä¸€æ¬¡å¯æ˜¯åˆ«äººå°†å¸Œæœ›å¯„æ‰˜äºä½ å‘¢ï¼Œæ‰“èµ·ç²¾ç¥æ¥ï¼
<br>
æœ‰å‘å›¾ä¸­ï¼Œè¾¹å˜æˆå•å‘çš„äº†ï¼Œä»»ä½•ä¸€æ¡è¾¹æ‰€é“¾æ¥çš„ä¸¤ä¸ªé¡¶ç‚¹éƒ½æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ï¼Œè¾¹çš„æœ‰å‘æ€§ï¼Œä½¿å¾—æ›´è´´åˆç°å®ä¸­çš„æŸäº›åœºæ™¯ã€‚è¿™ä¸€çœ‹èµ·æ¥æä¸ºå®¹æ˜“ä¹Ÿé¢‡ä¸ºè‡ªç„¶çš„æ”¹å˜ï¼Œå°†ä¼šå¯¹ç®—æ³•äº§ç”Ÿæ·±åˆ»çš„å½±å“ï¼ˆä¹¦ä¸­è¯´çš„ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä¹Ÿæ²¡æ„è¯†åˆ°å°†ä¼šæœ‰ä»€ä¹ˆå…·ä½“çš„å½±å“ï¼‰ã€‚ä¸ºäº†è¯´æ˜è¾¹çš„æ–¹å‘æ€§ï¼Œè€Œäº§ç”Ÿçš„ç»†å°æ–‡å­—å·®å¼‚æ‰€ä»£è¡¨çš„ç»“æ„ç‰¹æ€§æ­£æ˜¯æœ¬èŠ‚çš„é‡ç‚¹ã€‚
<br>
é‡ç‚¹éœ€è¦æˆ‘ä»¬ç†è§£æœ‰å‘å›¾ä¸­çš„å¯è¾¾æ€§ä¸æ— å‘å›¾ä¸­çš„è¿é€šæ€§ï¼Œè¿™ä¸¤ä¸ªæ¦‚å¿µçš„åŒºåˆ«ï¼Œæ¦‚å¿µä¸Šæœ‰å‘å›¾æ˜æ˜¾æ›´å¤æ‚ä¸€ç‚¹ï¼Œä½†æˆ‘ä»¬è¡¨ç¤ºæœ‰å‘å›¾çš„æ•°æ®ç»“æ„ç”šè‡³æ¯”æ— å‘å›¾æ›´ç®€å•ã€‚
<br>
api:

```java
package define;

public interface IDigraph {
    
    int V();
    int E();
    void addEdge(int w, int v);
    Iterable<Integer> adj(int v);
    IDigraph reverse();
    
    String toString();
}
```

<br>

å®ç°ï¼š



```java
package define;

import define.impl.LinkBag;

public class Digraph extends AbstructDirectedGraph{
    
    private final int v;
    
    private int e;
    
    private Bag<Integer>[] adj;
    
    public Digraph(int v) {
        this.v = v;
        this.e = 0;
        this.adj = (Bag<Integer>[]) new Bag[v];
        for (int i = 0; i < v; i++) {
            adj[i] = new LinkBag<>();
        }
    }
    
    

    @Override
    public int V() {
        return v;
    }

    @Override
    public int E() {
        return e;
    }

    @Override
    public void addEdge(int w, int v) {
        adj[w].add(v);
        e ++;
    }

    @Override
    public Iterable<Integer> adj(int v) {
        return adj[v];
    }

    @Override
    public IDigraph reverse() {
        Digraph r = new Digraph(v);
        for (int i = 0; i < v; i++) {
            for (int w : adj[i]) {
                r.addEdge(w, i);
            }
        }
        return r;
    }
}
```

<br>
è¿™ä»½æ•°æ®ç»“æ„ä¸æ— å‘å›¾ç›¸æ¯”ï¼Œå”¯ä¸€çš„åŒºåˆ«åªæœ‰addEdge,åŒæ—¶å¤šä¸ªreverseæ–¹æ³•ã€‚
<br>

## å¯è¾¾æ€§

<br>
åœ¨æ•°æ®ç»“æ„åŸºæœ¬æ²¡ä»€ä¹ˆå·®å¼‚çš„æƒ…å†µä¸‹ï¼Œå¯è¾¾æ€§è¿™ä¸ªå…¶å®è·Ÿæ— å‘å›¾ä¸­çš„æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ä¹Ÿæ˜¯æ²¡ä»€ä¹ˆå·®å¼‚çš„ã€‚
<br>
apiï¼š

```java
package algorithm.api;

public interface IDirectedDFS {
    boolean marked(int v);
}
```

<br>
å®ç°ï¼š

````java
package algorithm;

import algorithm.api.IDirectedDFS;
import define.Digraph;

public class DirectDFS implements IDirectedDFS {

    private boolean[] marked;

    public DirectDFS(Digraph g, int s) {
        marked = new boolean[g.V()];
        dfs(g, s);
    }

    public DirectDFS(Digraph g, Iterable<Integer> source) {
        marked = new boolean[g.V()];
        for (Integer i : source) {
            dfs(g, i);
        }
    }

    private void dfs(Digraph g, int s) {
        marked[s] = true;
        for (int w : g.adj(s)) {
            if (!marked[w]) {
                dfs(g, w);
            }
        }
    }

    @Override
    public boolean marked(int v) {
        return marked[v];
    }
}
````

<br>
ç›¸æ¯”äºæ— å‘å›¾ä¸­çš„æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œæ­¤å¤„å¤šäº†ä¸€ä¸ªå¤šç‚¹å¯è¾¾æ€§çš„æ–¹æ³•ã€‚
<br>
å¤šç‚¹å¯è¾¾æ€§çš„ä¸€ä¸ªå…¸å‹åº”ç”¨ä¾¿æ˜¯ï¼Œå†…å­˜ç³»ç»Ÿï¼Œä¸€ä¸ªé¡¶ç‚¹è¡¨ç¤ºä¸€ä¸ªå¯¹è±¡ï¼Œä¸€æ¡è¾¹è¡¨ç¤ºå¯¹è±¡å¯¹å¦ä¸€å¯¹è±¡çš„å¼•ç”¨ã€‚å½“æŸä¸ªå¯¹è±¡å…¥åº¦ä¸º0æ—¶ï¼Œåˆ™è¡¨ç¤ºæ²¡æœ‰ä»»ä½•å¯¹è±¡åœ¨å¼•ç”¨ä»–äº†ï¼Œæ­¤æ—¶å¯ä»¥åƒåœ¾å›æ”¶äº†ï¼ˆé”™è¯¯çš„ï¼Œæœ‰å¯èƒ½ä¸ºç¯ï¼Œè™½ç„¶å…¥åº¦ä¸ä¸º0ï¼‰ã€‚ç¨‹åºè¿è¡Œæ—¶ï¼Œæœ‰äº›å¯¹è±¡æ˜¯å¯ä»¥è®¿é—®çš„ï¼Œè€Œé‚£äº›ä¸ç”¨é€šè¿‡è¿™äº›å¯¹è±¡è¿›è¡Œè®¿é—®çš„å¯¹è±¡å°±åº”è¯¥è¢«å›æ”¶æ‰ã€‚
<br>
å¹¿åº¦ä¼˜å…ˆç®—æ³•çš„æ— å‘å›¾å®ç°ä¹Ÿä»…æ­¢éœ€è¦å°†å‚æ•°IGraph ä¿®æ”¹ä¸º IDigraphå³å¯ã€‚
<br>
å¯¹äºæ˜¯å¦å­˜åœ¨è·¯å¾„ï¼Ÿæœ€çŸ­è·¯å¾„ç­‰é—®é¢˜ä¸æœ‰å‘å›¾ä¸€è‡´ã€‚
<br>

## ç¯ä¸æœ‰å‘æ— ç¯å›¾

<br>
æœ‰å‘å›¾çš„ä¸€ä¸ªå…¸å‹åŸå‹åº”ç”¨ï¼šä¼˜å…ˆçº§é™åˆ¶ä¸‹çš„è°ƒåº¦é—®é¢˜ï¼ˆè¯¾ç¨‹ä¸å…ˆå¯¼è¯¾ç¨‹ï¼‰ã€‚
<br>
è€Œå¯¹äºè¿™ç±»é—®é¢˜çš„ä¸€ç§è§£ä¾¿æ˜¯ï¼šæ‹“æ‰‘æ’åºã€‚ç»™å®šä¸€å¹…æœ‰å‘å›¾ï¼Œå°†æ‰€æœ‰é¡¶ç‚¹æ’åºï¼Œä½¿å¾—æ‰€æœ‰çš„æœ‰å‘è¾¹å‡ä»æ’åœ¨å‰é¢çš„å…ƒç´ æŒ‡å‘æ’åœ¨åé¢çš„å…ƒç´ ã€‚
<br>
å¦‚æœä¸€ä¸ªä¼˜å…ˆçº§é™åˆ¶çš„é—®é¢˜ï¼Œå­˜åœ¨ç¯ï¼Œåˆ™å¿…ç„¶æ— è§£ã€‚
<br>

### æ‰¾ç¯

<br>
æœ‰å‘å›¾ä¸­æ‰¾ç¯ä¸æ— å‘å›¾ç±»ä¼¼ï¼Œæ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•å¦‚æœéå†åˆ°äº†æŸä¸ªä¹‹å‰å·²ç»éå†åˆ°ä¸”å°±åœ¨æœ¬æ¬¡è°ƒç”¨æ ˆä¸Šçš„ç»“ç‚¹ï¼Œæ­å–œï¼Œç¯æ‰¾åˆ°äº†ã€‚
<br>
api:

````java
package algorithm.api;

public interface IDirectedCycle {
    boolean hasCycle();
    Iterable<Integer> cycle();
}
````

<br>
å®ç°ï¼š

```java
package algorithm;

import algorithm.api.IDirectedCycle;
import define.Digraph;
import define.Stack;
import define.impl.ListStack;

public class DirectedCycle implements IDirectedCycle {

    private boolean[] marked;
    private int[] edgeTo;
    private Stack<Integer> cycle;
    private boolean [] onStack;

    public DirectedCycle(Digraph g) {
        marked = new boolean[g.V()];
        edgeTo = new int[g.V()];
        onStack = new boolean[g.V()];
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i);
            }
        }
    }

    private void dfs(Digraph g, int i) {
        marked[i] = true;
        onStack[i] = true;
        for (int j : g.adj(i)) {
            if (this.hasCycle()) {
                return;
            }else if (!marked[j]) {
                edgeTo[j] = i;
                dfs(g, j);
            }else if (onStack[j]) {
                cycle = new ListStack<>();
                for (int x = i; x != j; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(j);
            }
        }
        //é€’å½’è¿”å›çš„æ—¶å€™å°†å…¶æ’é™¤é€’å½’è°ƒç”¨æ•°ç»„
        onStack[i] = false;
    }

    @Override
    public boolean hasCycle() {
        return cycle != null;
    }

    @Override
    public Iterable<Integer> cycle() {
        return cycle;
    }
}
```

<br>
ä¼˜å…ˆçº§é™åˆ¶æ¡ä»¶ä¸‹çš„è°ƒåº¦é—®é¢˜ï¼Œç­‰ä»·äºè®¡ç®—æœ‰å‘æ— ç¯å›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹çš„æ‹“æ‰‘é¡ºåº
<br>

### é¡¶ç‚¹çš„æ·±åº¦ä¼˜å…ˆæ¬¡åº

<br>
åŸºæœ¬æ€æƒ³ï¼Œæ·±åº¦ä¼˜å…ˆçš„éå†ä¸­æ¯ä¸ªé¡¶ç‚¹éƒ½ä¼šè¢«éå†ä¸”åªä¼šè¢«éå†ä¸€æ¬¡ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨éå†çš„è¿‡ç¨‹ä¸­å°†æ‰«æåˆ°çš„é¡¶ç‚¹ä¿å­˜åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸­ã€‚äºæ˜¯é¡ºåºä¾¿æœ‰äº†ã€‚
<br>
å…¸å‹çš„åº”ç”¨ä¸­ä¸€èˆ¬å¦‚ä¸‹ä¸‰ç§æ’åºï¼š
<br>

1. å‰åºï¼Œé€’å½’è°ƒç”¨ä¹‹å‰å°†å…ƒç´ æ”¾å…¥é˜Ÿåˆ—ã€‚
2. åç»­ï¼Œé€’å½’è°ƒç”¨ä¹‹åå°†é¡¶ç‚¹æ”¾å…¥é˜Ÿåˆ—ã€‚
3. é€†åç»­ï¼Œé€’å½’è°ƒç”¨ä¹‹åå°†é¡¶ç‚¹å‹å…¥æ ˆã€‚



```java
package algorithm;

import define.Digraph;
import define.Queue;
import define.Stack;
import define.impl.ListQueue;
import define.impl.ListStack;
import edu.princeton.cs.algs4.In;

public class DepthFristOrder {
    private boolean[] marked;
    private Queue<Integer> pre;
    private Queue<Integer> post;
    private Stack<Integer> reversePost;

    public DepthFristOrder(Digraph g) {
        pre = new ListQueue<>();
        post = new ListQueue<>();
        reversePost = new ListStack<>();
        marked = new boolean[g.V()];
        
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i);
            }
        }
    }
    
    private void dfs(Digraph g, int i) {
        pre.enqueue(i);
        marked[i] = true;
        for (int j : g.adj(i)) {
            if (!marked[j]) {
                dfs(g, j);
                post.enqueue(i);
                reversePost.push(i);
            }
        }
    }
    
    public Iterable<Integer> pre() {
        return pre;
    }

    public Iterable<Integer> post() {
        return post;
    }

    public Iterable<Integer> reversePost() {
        return reversePost;
    }

}
```

<br>

### æ‹“æ‰‘æ’åº

<br>
å®é™…å–å¾—æ˜¯æ·±åº¦ä¼˜å…ˆç®—æ³•ä¸­çš„é€†ååºã€‚

```java
package algorithm;

import define.Digraph;

public class Topological {
    private Iterable<Integer> order;

    public Topological(Digraph g) {
        DirectedCycle cycleFinder = new DirectedCycle(g);
        if (!cycleFinder.hasCycle()) {
            DepthFristOrder dfo = new DepthFristOrder(g);
            order = dfo.reversePost();
        }
    }

    public Iterable<Integer> order() {
        return  order;
    }

    public boolean isDGA() {
        return order != null;
    }
    
}
```

<br>
ä¸ºä»€ä¹ˆé€†åç»­å°±æ˜¯æ‹“æ‰‘æ’åºå‘¢ï¼Ÿ
<br>
æ·±åº¦ä¼˜å…ˆçš„ç®—æ³•ä¸­ï¼Œaç»“ç‚¹è¿”å›äº†ï¼Œç„¶åæ‰æ˜¯bç»“ç‚¹è¿”å›ï¼Œé‚£ä¹ˆæŒ‰ç…§æ–¹å‘é¡ºåºä¸€å®šæ˜¯å…ˆbå†aï¼Œæ·±åº¦ä¼˜å…ˆï¼Œå…ˆè¿”å›çš„ä¸€å®šæ˜¯æ·±åº¦æ›´æ·±çš„ã€‚
<br>

## æœ‰å‘å›¾ä¸­çš„å¼ºè¿é€šæ€§

<br>
é¦–å…ˆå®šä¹‰å¼ºè¿é€šæ€§ï¼šæœ‰å‘å›¾ä¸­ä»»æ„ä¸¤ä¸ªç‚¹éƒ½æ˜¯ç›¸äº’å¯è¾¾çš„ï¼Œåˆ™è¯¥å›¾æ˜¯å¼ºè¿é€šçš„ã€‚
<br>
ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¼ºè¿é€šçš„ï¼Œå½“ä¸”ä»…å½“ï¼Œè¿™ä¸¤ä¸ªé¡¶ç‚¹éƒ½åœ¨ä¸€ä¸ªæ™®é€šçš„æœ‰å‘ç¯ä¸­ã€‚
<br>
æœ‰å‘å›¾çš„å¼ºè¿é€šæ€§æ˜¯ä¸€ç§é¡¶ç‚¹ä¹‹é—´çš„ç­‰ä»·å…³ç³»ï¼š
<br>
1.è‡ªåæ€§
<br>
2.å¯¹ç§°æ€§ï¼šabæ˜¯å¼ºè¿é€šçš„ï¼Œbaä¹Ÿæ˜¯å¼ºè¿é€šçš„ã€‚
<br>
3.ä¼ é€’æ€§ï¼šabï¼Œbcï¼Œac
<br>
å¼ºè¿é€šæ€§å°†é¡¶ç‚¹åˆ†ä¸ºäº†ä¸€äº›ç­‰ä»·ç±»ï¼Œæ¯ä¸€ä¸ªç­‰ä»·ç±»éƒ½æ˜¯ç”±ç›¸äº’å‡ä¸ºå¼ºè¿é€šçš„é¡¶ç‚¹çš„æœ€å¤§å­é›†ç»„æˆï¼Œæ¯ä¸€ä¸ªå­é›†éƒ½æ˜¯æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡ã€‚ï¼ˆå¼ºè¿é€šåˆ†é‡æ˜¯åŸºäºé¡¶ç‚¹æ¥å®šä¹‰çš„ï¼‰
<br>
å¦‚ä½•æ±‚è§£å¼ºè¿é€šåˆ†é‡å‘¢ï¼Ÿé€šè¿‡ç»™å‡ºä¸€äº›å·²çŸ¥æ¡ä»¶å¤–åŠ éƒ¨åˆ†çš„é€»è¾‘ï¼Œå¼•å¯¼å¹¶æ€è€ƒå‡ºä¸‹é¢çš„ç®—æ³•ï¼Œä»¥å½“å‰æˆ‘çš„èƒ½åŠ›è€Œè¨€æ˜¯è¿œè¿œä¸å¤Ÿçš„ï¼Œæ‰€ä»¥è¿™ç§æ—¶å€™å¼ºåˆ¶æ€§çš„è®°å¿†ä¹Ÿä¸å¤±ä¸ºä¸€ç§å¥½åŠæ³•ğŸ˜‚ã€‚
<br>
apiï¼š

```java
package algorithm.api;

public interface SCC {
    boolean stronglyConnected(int v, int w);

    int count();

    int id(int v);
}
```

<br>
å®ç°ï¼š

```java
package algorithm;

import algorithm.api.SCC;
import define.Digraph;

public class KosarajuSCC implements SCC {

    private boolean[] marked;
    private int[] id;
    private int count;

    public KosarajuSCC(Digraph g) {
        marked = new boolean[g.V()];
        id = new int[g.V()];
        DepthFristOrder order = new DepthFristOrder(g.reverse());
        for (int s : order.reversePost()) {
            if (!marked[s]) {
                dfs(g, s);
                count++;
            }
        }
    }

    private void dfs(Digraph g, int s) {
        marked[s] = true;
        id[s] = count;
        for (int w : g.adj(s)) {
            if (!marked[w]) {
                dfs(g, w);
            }
        }
    }

    @Override
    public boolean stronglyConnected(int v, int w) {
        return id[v] == id[w];
    }

    @Override
    public int count() {
        return count;
    }

    @Override
    public int id(int v) {
        return id[v];
    }
}
```

<br>
ä¸æ— å‘å›¾ä¸­å¯»æ‰¾è¿é€šåˆ†é‡ç›¸æ¯”æˆ‘ä»¬æ‰€åšçš„å°å°æ”¹åŠ¨ä»…ä»…æ˜¯

```java
for (int i = 0 ; i < g.v(), i++)
```

å˜æˆ

```java
for (int s : order.reversePost())
```

<br>
å¯¹ä¸Šé¢ç®—æ³•çš„æè¿°å¦‚ä¸‹ï¼š
<br>
1.å…ˆè®¡ç®—åå›¾çš„æ‹“æ‰‘æ’åºã€‚
<br>
2.åœ¨å›¾ä¸­è¿›è¡Œæ ‡å‡†çš„æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œä½†è¦æŒ‰ç…§åå›¾çš„æ‹“æ‰‘é¡ºåºæ¥éå†æœªè¢«æ ‡è®°çš„é¡¶ç‚¹ã€‚
<br>
3.è¢«åŒä¸€ä¸ªé€’å½’è®¿é—®åˆ°çš„é¡¶ç‚¹éƒ½åœ¨åŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ã€‚
<br>
ä¹¦ä¸­å…³äºè¯¥ç®—æ³•çš„æ­£ç¡®æ€§è§£é‡Šæ²¡çœ‹æ‡‚ï¼Œæˆ‘è¿™é‡Œç»™ä¸€ä¸ªç›´è§‚çš„ç†è§£ï¼ˆä¸èƒ½å«è¯æ˜ï¼‰
<br>
å›¾gï¼š1>2>3>4
<br>
åå›¾ï¼š4>3>2>1
<br>
åå›¾çš„é€†åç»­ï¼š4>3>2>1
<br>
ç°åœ¨æˆ‘ä»¬æŒ‰ç…§4321çš„é¡ºåºï¼Œæ·±åº¦ä¼˜å…ˆè®¿é—®å›¾ï¼ˆ1234ï¼‰ï¼Œå¦‚æœåœ¨å¯¹4è¿›è¡Œæ·±åº¦ä¼˜å…ˆè®¿é—®æ—¶ï¼Œæ ‡è®°äº†32åˆ™å¿…ç„¶å­˜åœ¨è·¯å¾„4-3-2ï¼Œå·²ç»å­˜åœ¨1234ï¼Œç°åœ¨åˆæœ‰äº†432ï¼Œæ•… 432æ˜¯ä¸€ä¸ªå¼ºè¿é€šã€‚æ²¡æœ‰ä¸æ¯«ä¸¥è°¨å¯è¨€ï¼Œä¸è¿‡åˆæœ‰é‚£ä¹ˆä¸€ç‚¹ç¬¦åˆç›´è§‰ã€‚ï¼ˆ2025-07-21 ä¾æ—§æ²¡æ‡‚ï¼Œä¸è¿‡ï¼Œä¹Ÿä¸éœ€è¦æ‡‚å¾—æ¯ä¸€ä¸ª...ï¼‰

<br>

## æœ‰å‘å›¾ä¸­çš„å¯è¾¾æ€§

<br>
æœ‰å‘å›¾gçš„ä¼ é€’é—­åŒ…ï¼šç›¸åŒé¡¶ç‚¹ç»„æˆçš„å¦ä¸€å¹…æœ‰å‘å›¾ï¼Œå¿…åŒ…ä¸­å­˜åœ¨v-wçš„è¾¹ï¼Œå½“ä¸”ä»…å½“gä¸­vå¯ä»¥åˆ°è¾¾wã€‚
<br>
api:

```java
package algorithm.api;

public interface ITransitiveClosure {
    boolean reachable(int v, int w);
}
```

<br>
å®ç°ï¼š

````java
package algorithm;

import algorithm.api.ITransitiveClosure;
import define.Digraph;

public class TransitiveClosure implements ITransitiveClosure {

    private DirectDFS[] all;

    public TransitiveClosure(Digraph g) {
        all = new DirectDFS[g.V()];
        for (int i = 0; i < g.V(); i++) {
            all[i] = new DirectDFS(g, i);
        }
    }

    @Override
    public boolean reachable(int v, int w) {
        return all[v].marked(w);
    }
}
````

<br>
è¿™ä¸æ˜¯ä¸€ä¸ªå¯ç”¨äºç”Ÿäº§çš„ç®—æ³•ï¼Œå…¶éœ€è¦æ„å»ºä»æ¯ä¸ªç‚¹å‡ºå‘è¿›è¡Œæ·±åº¦ä¼˜å…ˆç®—æ³•çš„å¯¹è±¡ã€‚æ‰€éœ€è¦çš„ç©ºé—´ä¸vå¹³æ–¹æˆæ­£æ¯”ã€‚
<br>

# æœ€å°ç”Ÿæˆæ ‘

![æœ€å°ç”Ÿæˆæ ‘](https://algs4.cs.princeton.edu/43mst/images/mst.png)

<br>
åŠ æƒå›¾ï¼šæ¯æ¡è¾¹å…³è”äº†ä¸€ä¸ªæƒé‡å€¼/æˆæœ¬çš„å›¾æ¨¡å‹ã€‚
<br>
ç”Ÿæˆæ ‘ï¼šå«æœ‰æ‰€æœ‰é¡¶ç‚¹çš„æ— ç¯è¿é€šå­å›¾ã€‚
<br>
åŠ æƒå›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼šæƒå€¼æœ€å°çš„ç”Ÿæˆæ ‘ã€‚
<br>
åœ¨è®¡ç®—æœ€å°ç”Ÿæˆæ ‘æ—¶ï¼Œæˆ‘ä»¬ä¸€èˆ¬æœ‰å¦‚ä¸‹é»˜è®¤çš„å‰æå‡è®¾ã€‚

1. åªè€ƒè™‘è¿é€šå›¾ï¼Œä¸è¿é€šçš„å›¾åˆ™å«æœ€å°ç”Ÿæˆæ£®æ—ã€‚
2. è¾¹çš„æƒé‡ï¼Œå¯æ­£ï¼Œå¯è´Ÿï¼Œå¯0ï¼Œä½†ä¸èƒ½ç›¸åŒã€‚å› ä¸ºä¸åŒè¾¹æƒé‡ç›¸åŒï¼Œåˆ™æœ€å°ç”Ÿæˆæ ‘å°±ä¸å”¯ä¸€äº†ã€‚



æ ‘çš„ä¸¤ä¸ªæ€§è´¨ï¼š

1. ç”¨ä¸€æ¡è¾¹è¿æ¥æ ‘ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªç¯ã€‚
2. ä»æ ‘ä¸­åˆ å»ä»»æ„ä¸€æ¡è¾¹éƒ½ä¼šå¾—åˆ°ä¸¤ä¸ªç‹¬ç«‹çš„æ ‘ã€‚



å›¾çš„ä¸€ç§åˆ‡åˆ†ï¼šå°†æ‰€æœ‰é¡¶ç‚¹åˆ†æˆä¸¤ä¸ªéç©ºä¸”ä¸é‡å çš„é›†åˆï¼Œæ¨ªåˆ‡è¾¹å°±æ˜¯è¿æ¥ä¸¤ä¸ªå±äºä¸åŒé›†åˆé¡¶ç‚¹çš„è¾¹ã€‚
<br>
åˆ‡åˆ†å®šç†ï¼šä¸€å¹…åŠ æƒå›¾ä¸­ï¼Œç»™å®šä»»æ„çš„åˆ‡åˆ†ï¼Œå…¶æ¨ªåˆ‡è¾¹ä¸­æƒé‡æœ€å°çš„å¿…å®šå±äºæœ€å°ç”Ÿæˆæ ‘ã€‚
<br>
ä¸‹é¢æ˜¯cs61bä¸­åšçš„ä¸€ç‚¹è®°å½•ï¼š
<br>
Minimum spanning tree is spanning tree of minimum total weight
only in **undirected** graph as subgraph:

1. is connected
2. is acyclic
3. includes all of the vertices



1&2 determine it is tree,3 makes is spanning
<br>
æ˜¯å¦å­˜åœ¨æŸä¸ªé¡¶ç‚¹ï¼Œå…¶æœ€çŸ­è·¯å¾„æ ‘ï¼Œæ°å¥½æ˜¯è¯¥å›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼Ÿ--no
<br>
æœ€çŸ­è·¯å¾„æ ‘ï¼Œä¾èµ–äºèµ·å§‹èŠ‚ç‚¹ï¼Œè€Œæœ€å°ç”Ÿæˆæ ‘æ˜¯å›¾çš„å±æ€§ã€‚
<br>

<br>
è®¡ç®—æœ€å°ç”Ÿæˆæ ‘ï¼š
<br>
Cut Property
<br>
æœ€å°äº¤å‰è¾¹ï¼Œä¸€å®šæ˜¯æœ€å°ç”Ÿæˆæ ‘çš„ä¸€éƒ¨åˆ†ã€‚ï¼ˆè¾¹å¦‚æœä¸æ˜¯å”¯ä¸€çš„ï¼Œæœ€å°ç”Ÿæˆæ ‘ä¹Ÿå¯èƒ½ä¸æ˜¯å”¯ä¸€çš„ï¼‰
<br>
 Prim`s Algorithm æœ‰æ•ˆå…·ä½“å®ç°ï¼š`

ç±»ä¼¼djï¼Œdjå…³æ³¨çš„æ˜¯åˆ°æºæœ€çŸ­çš„è·¯å¾„ï¼Œprimå…³å¿ƒæ ‘çš„æ€»æƒé‡ï¼Œç¡®å®šä¿ç•™é‚£ä¸€æ¡è·¯å¾„çš„åå¥½ä¸åŒï¼Œå…¶ä½™åŸºæœ¬ä¸€è‡´ã€‚
ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œç§»é™¤èŠ‚ç‚¹æ—¶ï¼Œrelaxåˆ°éå·²ç¡®å®šç‚¹çš„è¾¹ï¼Œå†³å®šä¿ç•™é‚£ä¸€æ¡è¾¹ã€‚
<br>
Kruskal`s Algorithm:
<br>
è¾¹æ’åºï¼Œä»å°åˆ°å¤§ï¼Œä¾æ¬¡æ·»åŠ è¾¹ç›´åˆ°v-1ï¼ˆé¿å…ç¯ï¼‰ï¼›
<br>
ä¼˜å…ˆçº§é˜Ÿåˆ—
<br>
ä¸ç›¸äº¤é›†ï¼šæ£€æµ‹ç¯
<br>
æ¯æ¬¡æ·»åŠ éç¯çš„è¾¹ï¼Œå¯ä»¥ç†è§£ä¸ºä¸¤ä¸ªå‰²ä¸­å–æœ€çŸ­ã€‚
<br>
åˆ‡åˆ†å®šç†æ˜¯è§£å†³æœ€å°ç”Ÿæˆæ ‘é—®é¢˜çš„æ‰€æœ‰ç®—æ³•åŸºç¡€ï¼Œè¿™äº›ç®—æ³•éƒ½å¯ä»¥ç†è§£ä¸ºä¸€ç§è´ªå¿ƒç®—æ³•çš„ç‰¹æ®Šæƒ…å†µï¼š
<br>
ä½¿ç”¨åˆ‡åˆ†å®šç†æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘çš„ä¸€æ¡è¾¹ï¼Œä¸æ–­çš„é‡å¤ç›´åˆ°æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘çš„æ‰€æœ‰è¾¹ã€‚

![Prim's MST algorithm](https://algs4.cs.princeton.edu/43mst/images/prim.png)

å‰é¢è¡¨ç¤ºæ— å‘å›¾&æœ‰å‘å›¾ ä½¿ç”¨çš„æ•°æ®ç»“æ„æ ¸å¿ƒéƒ½æ˜¯é‚»æ¥è¡¨æ•°ç»„ï¼Œè¡¨ç¤ºåŠ æƒå›¾æ—¶ï¼Œç¨æœ‰ä¸åŒï¼Œæˆ‘ä»¬æ–°å¢äº†è¾¹è¿™ä¸€å¯¹è±¡ï¼Œæ ¸å¿ƒåˆ™æ˜¯é¢†æ¥è¾¹æ•°ç»„ã€‚
<br>
æ— å‘åŠ æƒå›¾çš„æ•°æ®ç»“æ„-è¾¹ï¼š

```java
package define;

public class Edge implements Comparable<Edge>{

    private final int v;
    private final int w;
    private final double weight;

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int either() {
        return v;
    }

    public int other(int vertex) {
        if (vertex == v) return w;
        else if (vertex == w) return v;
        else throw new RuntimeException("ä¸å­˜åœ¨çš„ç‚¹");
    }

    @Override
    public int compareTo(Edge o) {
        if (this.weight() < o.weight()) return -1;
        else if (this.weight() > o.weight()) return 1;
        else return 0;
    }

    public String toString() {
        return String.format("%d-%d %.2f", v, w, weight);
    }
}
```

<br>
æ— å‘åŠ æƒå›¾çš„æ•°æ®ç»“æ„-å›¾ï¼š

```java
package define;

import define.impl.LinkBag;
import edu.princeton.cs.algs4.In;

public class EdgeWeightedGraph {

    private final int v;
    private int e;
    private Bag<Edge>[] adj;

    public EdgeWeightedGraph(int v) {
        this.v = v;
        this.e = 0;
        adj = (LinkBag<Edge>[])new LinkBag[v];
        for (int i = 0; i < v; i++) {
            adj[i] = new LinkBag<>();
        }
    }

    public EdgeWeightedGraph(In in) {
        this(in.readInt());
        int e  = in.readInt();
        for (int i = 0; i < e; i++) {
            int v = in.readInt();
            int w = in.readInt();
            double weight = in.readDouble();
            Edge edge = new Edge(v, w, weight);
            adj[v].add(edge);
            adj[w].add(edge);
        }
    }

    public int v() {
        return v;
    }
    public int e() {
        return e;
    }
    public void addEdge(Edge e) {
        int v = e.either(),w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        this.e++;
    }

    public Iterable<Edge> adj(int v) {
        return adj[v];
    }

}
```

<br>
æˆ‘ä»¬å·²ç»å®šä¹‰äº†åŠ æƒå›¾çš„æ•°æ®ç»“æ„ï¼Œnowï¼Œstart algorithmï¼
<br>

## Primç®—æ³•

<br>
æ ¸å¿ƒæ€æƒ³ä¾¿æ˜¯æ‰¾æƒé‡æœ€å°çš„æ¨ªåˆ‡è¾¹ã€‚æ¯æ¬¡å°†ä¸‹ä¸€æ¡è¿æ¥æ ‘ä¸­çš„é¡¶ç‚¹ï¼Œä¸æ‰€æœ‰ä¸åœ¨æ ‘ä¸­çš„é¡¶ç‚¹ä¸”æƒé‡æœ€å°çš„è¾¹åŠ å…¥æ ‘ä¸­
<br>
é‡ç‚¹ï¼šä½¿ç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥ä¿å­˜æ¨ªåˆ‡è¾¹ï¼Œæˆ‘ä»¬ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­é€‰æ‹©æœ€å°æƒé‡æ¨ªåˆ‡è¾¹æ—¶éœ€è¦å°†å·²å­˜åœ¨æ ‘ä¸­çš„è¾¹&ä¸¤ä¸ªé¡¶ç‚¹éƒ½åœ¨æ ‘ä¸­çš„è¾¹ç§»é™¤ä¼˜å…ˆé˜Ÿåˆ—ã€‚

å³æ—¶å®ç°ä¾¿æ˜¯æ¯ä¸€æ­¥éƒ½å¤„ç†å¹¶ç§»é™¤å¤±æ•ˆçš„è¾¹ã€‚

å»¶æ—¶å®ç°åˆ™æ˜¯è¾¹ç•™åœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼Œéœ€è¦åˆ é™¤çš„æ—¶å€™å†æ£€æŸ¥è¾¹çš„æœ‰æ•ˆæ€§ã€‚

æ›´å¤šçš„ç»†èŠ‚  ->  show me code

![Prim's algorithm (eager implementation) for the minimum spanning tree problem](https://algs4.cs.princeton.edu/43mst/images/prim-eager.png)

primç®—æ³•çš„å»¶æ—¶å®ç°ï¼š

````java
package algorithm;

import define.Edge;
import define.EdgeWeightedGraph;
import define.Queue;
import define.impl.ListQueue;
import edu.princeton.cs.algs4.MinPQ;

public class LazyPrimMST {
    private boolean[] marked;//æ ‡è®°å­˜åœ¨ä¸æ ‘ä¸­çš„é¡¶ç‚¹
    private Queue<Edge> mst;//æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ã€‚
    private MinPQ<Edge> pq;//æ¨ªåˆ‡è¾¹

    /**
     * å°†å½“å‰é¡¶ç‚¹åŠ å…¥æœ€å°ç”Ÿæˆæ ‘ï¼Œå¹¶å°†åŠ å…¥åä¸ä¹‹ç›¸é‚»çš„è¾¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
     * @param g
     * @param v
     */
    private void visit(EdgeWeightedGraph g, int v) {
        marked[v] = true;
        for (Edge e : g.adj(v)) {
            if (!marked[e.other(v)]) pq.insert(e);
        }
    }
    
    
    public LazyPrimMST(EdgeWeightedGraph g) {
        pq = new MinPQ<>();
        marked = new boolean[g.v()];
        mst = new ListQueue<>();
        visit(g, 0);
        while (!pq.isEmpty()) {
            Edge e = pq.delMin();
            int v = e.either(), w = e.other(v);
            if (marked[v] && marked[w]) continue;//è·³è¿‡å¤±æ•ˆçš„è¾¹ï¼Œä½†ä¸ä¼šå°†å…¶ä»pqä¸­ç§»é™¤
            mst.enqueue(e);
            if (!marked[v]) visit(g, v);
            if (!marked[w]) visit(g, w);
        }
    }
    
    public Iterable<Edge> edges() {
        return mst;
    }
    
    public double weight() {
        double rs = 0.0d;
        for (Edge e : mst) {
            rs += e.weight();
        }
        return rs;
    }
}
````

<br>
ä¸Šé¢è¿™ä¸ªç®—æ³•çš„ä¸»è¦è€—æ—¶åœ¨äºä¼˜å…ˆé˜Ÿåˆ—çš„æ’å…¥ä¸delMinã€‚
<br>
å¯¹äºä¸Šé¢çš„ä¼˜åŒ–ï¼Œä»ä¼˜å…ˆé˜Ÿåˆ—çš„è§’åº¦å‡ºå‘ï¼Œå¯ä»¥è¿›è¡Œä¸¤æ¬¡ä¼˜åŒ–ï¼Œ1.æˆ‘ä»¬åªå…³å¿ƒï¼Œéæ ‘é¡¶ç‚¹ä¸æ ‘è¿æ¥çš„è¾¹ã€‚2.åœ¨æŸä¸€ä¸ªéæ ‘é¡¶ç‚¹ä¸æ ‘è¿æ¥çš„è¾¹ä¸­ï¼Œæˆ‘ä»¬åªå…³å¿ƒæƒé‡æœ€å°çš„é‚£æ¡è¾¹ï¼Œæ›´å¤šçš„å®ç°ç»†èŠ‚ï¼šshow me code
<br>
primç®—æ³•çš„å³æ—¶å®ç°ï¼š

```java
package algorithm;

import define.Edge;
import define.EdgeWeightedGraph;
import define.IndexMinPriorityQueue;

public class PrimMST {
    private Edge[] edgeTo;//ä¿å­˜è¯¥ç‚¹åˆ°æ ‘çš„æƒé‡æœ€å°çš„è¾¹ï¼Œæœ€ç»ˆå°±æ˜¯æœ€å°ç”Ÿæˆæ ‘çš„æ‰€æœ‰è¾¹ã€‚
    private double[] distTo;//edgeToä¸­å¯¹åº”è¾¹çš„æƒé‡ã€‚
    private boolean[] marked;//æ ‡è®°åœ¨æ ‘ä¸­çš„é¡¶ç‚¹ã€‚
    private IndexMinPriorityQueue<Double> pq; //ä¿å­˜æ¨ªåˆ‡è¾¹,æ•°ç»„ä¸‹è¾¹å¯¹åº”çš„ç‚¹å¯¹åº”çš„æƒé‡ã€‚
    
    
    private void visit(EdgeWeightedGraph g, int v) {
        marked[v] = true;
        for (Edge e : g.adj(v)) {
            int w = e.other(v);
            if (marked[w]) continue;
            if (e.weight() < distTo[w]) {
                edgeTo[w] = e;
                distTo[w] = e.weight();
                if (pq.contains(w)) {
                    pq.change(w, distTo[w]);
                } else {
                    pq.insert(w, distTo[w]);
                }
            }
        }
    }
    
    public PrimMST(EdgeWeightedGraph g) {
        edgeTo = new Edge[g.v()];
        distTo = new double[g.v()];
        marked = new boolean[g.v()];
        for (int i = 0; i < g.v(); i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        pq = new IndexMinPriorityQueue<>(g.v());
        
        distTo[0] = 0.0;
        pq.insert(0, distTo[0]);
        while (!pq.isEmpty()) {
            visit(g, pq.delMin());
        }
    }
}
```

<br>
ç®—æ³•ä¸­ï¼Œéå†å½“å‰æœ€å°æƒé‡æ–°å¢åŠ å…¥æ ‘çš„é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹ï¼Œå¯¹äºå…³è”è¾¹æ¯ä¸€ä¸ªæ¶‰åŠçš„é¡¶ç‚¹ï¼š
<br>
1.å¦‚æœè¯¥é¡¶ç‚¹å·²åœ¨æ ‘ä¸­ï¼Œåˆ™è·³è¿‡ã€‚
<br>
2.å¦‚æœè¯¥é¡¶ç‚¹ï¼Œæ–°çš„è¾¹æƒé‡å°äºå·²å­˜åœ¨çš„è¾¹ï¼Œæ›´æ–°edgeTo & distToï¼ŒåŒæ—¶å¦‚æœä¼˜å…ˆé˜Ÿåˆ—ä¸­æ²¡æœ‰è¯¥é¡¶ç‚¹åˆ™åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæ¨ªåˆ‡è¾¹ï¼‰ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æ›´æ–°è¯¥æ¨ªåˆ‡è¾¹çš„æƒé‡ã€‚
<br>
æœ€ç»ˆä¼˜å…ˆé˜Ÿåˆ—ä¸­åªä¼šä¿å­˜æ¨ªåˆ‡è¾¹ï¼Œä¸”ä¸€ä¸ªé¡¶ç‚¹åªæœ‰ä¸€æ¡ï¼ˆæƒé‡æœ€å°çš„é‚£ä¸ªï¼‰ã€‚
<br>
å°½ç®¡å»¶æ—¶&å³æ—¶ï¼Œæ•°æ®ç»“æ„ä¸åŒï¼Œç®—æ³•ä¹Ÿæœ‰å·®å¼‚ï¼Œæœ¬è´¨éƒ½æ˜¯æ‰¾æœ€å°æ¨ªåˆ‡è¾¹ç„¶ååŠ å…¥æœ€å°ç”Ÿæˆæ ‘ã€‚
<br>

## Kruskalç®—æ³•

<br>
ç¬¬äºŒç§ç®—æ³•çš„æ ¸å¿ƒæ€æƒ³ä¾¿æ˜¯ï¼šå°†æ‰€æœ‰çš„è¾¹æŒ‰æƒé‡æ’åºï¼Œå°†æœ€å°çš„å–å‡ºæ¥ï¼Œå¦‚æœåœ¨å·²æœ‰çš„æ ‘ä¸­åŠ å…¥è¯¥è¾¹ä¸æ„æˆç¯åˆ™å°†è¯¥è¾¹åŠ å…¥ç”Ÿæˆæ ‘ã€‚

![Kruskal's algorithm for the minimum spanning tree problem](https://algs4.cs.princeton.edu/43mst/images/kruskal.png)





```java
package algorithm;

import define.*;
import define.impl.ListQueue;
import edu.princeton.cs.algs4.MinPQ;

public class KruskalMST {
    private Queue<Edge> mst;

    public KruskalMST(EdgeWeightedGraph g) {
        mst = new ListQueue<>();//æœ€å°ç”Ÿæˆæ ‘ä¸­çš„è¾¹
        MinPQ<Edge> pq = new MinPQ<>();// å­˜æ”¾è¾¹çš„ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (Edge e : g.edges()) {
            pq.insert(e);
        }
        UnionFind uf = new WeightedQuickUnion(g.v());//ç”¨äºåˆ¤æ–­ç‚¹æ˜¯å·²ç»å­˜åœ¨ä¸æ ‘ä¸­
        while (!pq.isEmpty() && mst.size() < g.v() - 1) {
            Edge e = pq.delMin();
            int v = e.either(),w = e.other(v);
            if (uf.connected(v, w)) continue;
            uf.union(v, w);
            mst.enqueue(e);
        }
    }
    
    public Iterable<Edge> edges() {
        return mst;
    }

}
```

<br>

# æœ€çŸ­è·¯å¾„

<br>
ç»ˆäºå¼€å§‹å‘è¿™å‘¨è®¡åˆ’ä¸­çš„æœ€åçš„å ¡å’å¼€å§‹è¿›æ”»äº†ï¼Œå…³äºæœ€å°ç”Ÿæˆæ ‘éƒ¨åˆ†ï¼Œç²¾åŠ›ä¸€ç‚¹éƒ½ä¸é›†ä¸­ï¼Œå›«å›µåæ£èˆ¬å‹‰å¼ºç®—æ˜¯å®Œæˆäº†ï¼Œå¯¹äºæˆ‘çš„ç¬¬ä¸€ç¯‡çœŸæ­£æ„ä¹‰ä¸Šçš„é•¿ç¯‡ï¼Œä¸€å®šè¦å®Œæˆå…¨éƒ¨çš„å†…å®¹ï¼é‚£å°±é€Ÿæˆ˜é€Ÿå†³ï¼
<br>
ä½œä¸ºåœ°ç†èƒŒæ™¯å‡ºèº«çš„äººï¼Œå¯¹æœ€çŸ­è·¯å¾„ç›¸å…³é—®é¢˜çš„æœ€å…ˆæƒ³åˆ°çš„å°±æ˜¯ï¼Œarcgisä¸­çš„è·¯å¾„åˆ†æï¼Œåœ°å›¾ä¸­çš„æ‰¾è·¯ã€‚æœ€çŸ­è·¯å¾„æ¨¡å‹æœ€ç›´è§‚çš„ä¾¿æ˜¯è·¯å¾„é—®é¢˜ï¼Œåœ°å›¾&ç½‘ç»œç­‰ï¼Œä¹Ÿæœ‰ä»»åŠ¡è°ƒåº¦ï¼Œä»¥åŠä¼¼ä¹ä¸å›¾ï¼Œæ²¡æœ‰ä»»ä½•å…³ç³»çš„å¥—æ±‡é—®é¢˜ã€‚
<br>
æˆ‘ä»¬ç ”ç©¶çš„é‡ç‚¹æ˜¯å•ç‚¹æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œå‡è®¾æ¶‰åŠçš„éƒ½æ˜¯æœ‰å‘åŠ æƒå¼ºè¿é€šå›¾ï¼Œé‚£ä¹ˆç»“æœå°±æ˜¯ä¸€æ£µå›ºå®šäº†æ ¹èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„æ ‘ã€‚
<br>
æœ€çŸ­è·¯å¾„é—®é¢˜çš„èƒŒæ™¯æ˜¯æœ‰å‘åŠ æƒå›¾ï¼Œsoï¼Œå…ˆä»‹ç»æœ‰å‘åŠ æƒå›¾çš„æ•°æ®ç»“æ„ã€‚åŸºæœ¬å¯ä»¥å‚è€ƒåŠ æƒå›¾çš„æ•°æ®ç»“æ„å®ç°ï¼Œå”¯ä¸€ä¸åŒçš„åˆ™åœ¨äºè¾¹æ˜¯æœ‰å‘çš„ã€‚
<br>

## æœ‰å‘åŠ æƒå›¾

<br>
æœ‰å‘åŠ æƒè¾¹ï¼š

```java
package define;

public class DirectedEdge {
    private final int v;
    private final int w;
    private final double weight;

    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int form() {
        return v;
    }

    public int to() {
        return w;
    }

    public String toString() {
        return String.format("%d->%d %.2f", v, w, weight);
    }
}
```

<br>
æœ‰å‘åŠ æƒå›¾ï¼š

```java
package define;

import define.impl.LinkBag;

public class EdgeWeightedDigraph {
    private final int v;
    private int e;
    private Bag<DirectedEdge>[] adj;

    public EdgeWeightedDigraph(int v) {
        this.v = v;
        this.e = 0;
        adj = (Bag<DirectedEdge>[]) new Bag[v];
        for (int i = 0; i < v; i++) {
            adj[i] = new LinkBag<>();
        }
    }

    public int v() {
        return v;
    }
    public int e() {
        return e;
    }
    public void addEdge(DirectedEdge e) {
        adj[e.form()].add(e);
        this.e++;
    }

    public Iterable<DirectedEdge> adj(int v) {
        return adj[v];
    }

    public Iterable<DirectedEdge> edges() {
        Bag<DirectedEdge> bag = new LinkBag<>();
        for (int i = 0; i < this.v; i++) {
            for (DirectedEdge e : adj[i]) {
                bag.add(e);
            }
        }
        return bag;
    }
}
```

<br>

## æœ€çŸ­è·¯å¾„api

```java
package algorithm.api;

import define.DirectedEdge;

public interface SP {
    double distTo(int v);
    boolean hasPathTo(int v);
    Iterable<DirectedEdge> pathTo(int v);
}
```

<br>
åœ¨ä»‹ç»å…·ä½“çš„ç®—æ³•å‰ï¼Œå¯ä»¥å›é¡¾ä¸‹å‰é¢çš„å¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚
<br>
å®ç°æœ€çŸ­è·¯å¾„ç®—æ³•çš„æ ¸å¿ƒæ¦‚å¿µï¼šæ¾å¼›ï¼ˆrelaxationï¼‰
<br>
è¾¹çš„æ¾å¼›ï¼šæ”¾æ¾è¾¹ v -> w æ„å‘³ç€æ£€æŸ¥såˆ°wçš„æœ€çŸ­è·¯å¾„ï¼Œæ˜¯å¦æ˜¯å…ˆä»såˆ°vï¼Œç„¶åç”±våˆ°wï¼Œæ˜¯åˆ™æ›´æ–°ç›¸å…³æ•°æ®ç»“æ„ã€‚

```java
private void relax(DirectedEdge e) {
  int v = e.from(),w = e.to();
  if (distTo[w] > distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = ve;
  }
}
```

<br>
é¡¶ç‚¹çš„æ¾å¼›ï¼šæ”¾æ¾ä»é¡¶ç‚¹æŒ‡å‡ºçš„æ‰€æœ‰è¾¹ï¼Œé€æ¡æ£€æŸ¥ã€‚

```java
private void relax(EdgeWeightedDigraph g, int v) {
  for (DirectedEdge e : g.adj(v)) {
    int w = e.to();
    if (distTo[w] > distTo[v] + e.weight()) {
      distTo[w] = distTo[v] + e.weight();
      edgeTo[w] = e;
    }
  }
}
```

<br>
æ¾å¼›æ“ä½œï¼Œå¯ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„ç†è®ºè¯æ˜ï¼š
<br>
å‘½é¢˜ï¼šå½“ä¸”ä»…å½“ï¼Œå¯¹äºvåˆ°wçš„ä»»æ„è¾¹eï¼Œéƒ½æ»¡è¶³distTo[w] <= distTo[v] +e.weight()æ—¶ï¼Œä»–ä»¬æ˜¯æœ€çŸ­è·¯å¾„ã€‚
<br>
å¿…è¦æ€§ï¼ˆæ»¡è¶³bä¸€å®šè¦æœ‰aï¼‰ï¼šæœ€çŸ­è¾¹ï¼Œä¸€å®šæ»¡è¶³å…¬å¼ï¼Œåè¯æ³•ï¼Œå­˜åœ¨å¤§äºï¼Œåˆ™ä¸€å®šå¯ä»¥ç”¨å½“å‰æ›¿æ¢å¤§äºã€‚
<br>
å……åˆ†æ€§ï¼ˆa æ¨ bï¼‰ï¼šæ»¡è¶³å…¬å¼çš„å°±æ˜¯æœ€çŸ­è¾¹ã€‚
<br>
1.å…¬å¼æ¨å¯¼å‡ºï¼šdistTo[w] <= e1.weight() + ... + ek.weight() = OPT(sw);
<br>
2.ä»»ä½•ä¸€æ¡è¾¹çš„è·¯å¾„ä¸€å®šæ˜¯å¤§äºç­‰ä¸æœ€çŸ­è¾¹çš„
<br>
ç»¼åˆï¼šOPT(sw) <= distTo[w] <= OPT(sw)   ç­‰ä»· distTo[w] = OPT(sw);
<br>
é€šç”¨ç®—æ³•ï¼šæ”¾æ¾æ‰€æœ‰è¾¹ï¼Œç›´åˆ°ä¸å­˜åœ¨æœ‰æ•ˆè¾¹ä¸ºæ­¢ã€‚
<br>

## Dijkstraç®—æ³•

<br>
æœ€æ—©æ¥è§¦djç®—æ³•æ˜¯è®¡ç®—æœºç½‘ç»œä¸­çš„è·¯ç”±éƒ¨åˆ†ï¼Œä¸¥æ ¼è®²æˆ‘å·²ç»æ¥è§¦äº†è‡³å°‘ä¸‰æ¬¡ï¼Œå¯¹å…¶çš„æ¨¡ç³Šå°è±¡åªæœ‰ï¼š
<br>
1.é€‰ä¸€ä¸ªç‚¹å¼€å§‹ï¼Œè·å–å…¶æ‰€æœ‰è¾¹ã€‚
<br>
2.é€‰è¾¹ä¸­æƒé‡æœ€å°çš„ï¼Œå°†å…¶çº³å…¥edgeToæ•°ç»„ã€‚
<br>
å¯ä»¥ç†è§£ä¸º æœ‰å‘åŠ æƒå›¾ä¸­çš„åˆ¶å®šèµ·ç‚¹çš„æœ€å°ç”Ÿæˆæ ‘è·¯å¾„ã€‚äºŒè€…ä¸€å¤§å·®å¼‚ä¾¿æ˜¯ï¼Œprimä¸­æ¯æ¬¡æ·»åŠ çš„æ˜¯è·ç¦»æ ‘æœ€è¿‘çš„é¡¶ç‚¹ï¼Œdjç®—æ³•åˆ™æ˜¯æ·»åŠ çš„è·ç¦»èµ·ç‚¹æœ€è¿‘çš„é¡¶ç‚¹ã€‚ä¸€ä¸ªdistTo[w]ä¸­ç»Ÿè®¡çš„æ˜¯ wåˆ°æ ‘çš„æƒé‡ï¼Œä¸€ä¸ªç»Ÿè®¡çš„æ˜¯wåˆ°èµ·ç‚¹çš„æƒé‡ã€‚
<br>
çœ‹åˆ°djç®—æ³•ï¼Œæ‰æ„è¯†åˆ°primç®—æ³•çš„é‡è¦æ€§ï¼è€Œåœ¨ä¸Šåˆå­¦ä¹ primç®—æ³•æ—¶ï¼Œæ ¹æœ¬æ²¡ç”¨è„‘...

```java
package algorithm;

import define.DirectedEdge;
import define.EdgeWeightedDigraph;
import define.IndexMinPriorityQueue;
import define.Stack;
import define.impl.ListStack;

public class DijkstraSP {
    
    private DirectedEdge[] edgeTo;
    private double[] distTo;
    private IndexMinPriorityQueue<Double> pq;
    
    public DijkstraSP(EdgeWeightedDigraph g, int s) {
        edgeTo = new DirectedEdge[g.v()];
        distTo = new double[g.v()];
        pq = new IndexMinPriorityQueue<>(g.v());
        
        for (int i = 0; i < g.v(); i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0.0D;
        pq.insert(0, distTo[s]);
        while (!pq.isEmpty()) {
            
        }
    }
    
    private void relax(EdgeWeightedDigraph g, int v) {
        for (DirectedEdge e : g.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (pq.contains(w)) {
                    pq.change(w, distTo[v] + e.weight());
                } else {
                    pq.insert(w, distTo[w]);
                }
            }
        }
    }
    
    public double distTo(int v) {
        return distTo[v];
    }
    
    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }
    
    public Iterable<DirectedEdge> pathTo(int v) {
        Stack<DirectedEdge> stack = new ListStack<>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.form()]) {
            stack.push(e);
        }
        return stack;
    }
}
```

<br>
æ³¨æ„ï¼šdijkstraç®—æ³•ï¼Œè§£å†³çš„æ˜¯éè´Ÿæƒé‡çš„åŠ æƒæœ‰å‘å›¾ä¸­æœ€çŸ­è·¯å¾„é—®é¢˜ã€‚
<br>

## åŠ æƒæ— ç¯æœ‰å‘å›¾-æ±‚æœ€çŸ­è·¯å¾„

<br>
å°†æ‹“æ‰‘æ’åºä¸æ±‚æœ€çŸ­è·¯å¾„ç»“åˆèµ·æ¥ï¼Œä¾¿æ˜¯åŠ æƒæ— ç¯å›¾ä¸­æ‰¾ã€‚

```java
package algorithm;

import define.DirectedEdge;
import define.EdgeWeightedDigraph;

public class AcyclicSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;

    private void relax(EdgeWeightedDigraph g, int v) {
        for (DirectedEdge e : g.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
            }
        }
    }

    public AcyclicSP(EdgeWeightedDigraph g, int v) {
        edgeTo = new DirectedEdge[g.v()];
        distTo = new double[g.v()];
        for (int i = 0; i < g.v(); i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        distTo[v] = 0.0;

        Topological top = new Topological(g);
        for (int v : top.order()) {
            relax(g, v);
        }

    }
}
```

<br>
è¿™ä¸ªç®—æ³•æ˜¯ä¸èƒ½ç›´æ¥è¿è¡Œçš„ï¼Œå› ä¸ºæ²¡æœ‰å¯¹æ‹“æ‰‘æ’åºå…¼å®¹ã€‚
<br>
ä¸ºä»€ä¹ˆæŒ‰ç…§æ‹“æ‰‘æ’åºï¼Œè¿è¡Œé¡¶ç‚¹æ”¾æ¾å°±èƒ½æ‰¾åˆ°æœ€çŸ­è·¯å¾„å‘¢ï¼Ÿ
<br>
è·å–æœ€çŸ­è·¯å¾„çš„æ ¸å¿ƒæ€æƒ³ä¾¿æ˜¯ distTo[w] <= ditsTo[v] + e.weight();é‚£ä¹ˆè¦æƒ³ä»wä½œä¸ºèµ·ç‚¹å¼€å§‹æ‰¾ä¸‹ä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œå¿…é¡»è¦å›ºå®šsåˆ°wçš„å€¼ï¼Œè€Œæ‰€æœ‰æŒ‡å‘wçš„è¾¹éƒ½å¯èƒ½æ”¹å˜distTo[w]çš„å€¼ã€‚
<br>
djçš„åšæ³•æ˜¯é€‰å½“å‰æ‰€æœ‰æ¨ªåˆ‡è¾¹ä¸­ä¸sæœ€çŸ­çš„é‚£ä¸ªï¼ˆwï¼‰ï¼Œçº³å…¥æœ€çŸ­è·¯å¾„æ ‘ã€‚å› ä¸ºéè´Ÿï¼Œå¦‚æœè¿˜æœ‰å…¶ä»–è·¯å¾„åˆ°wæ¯”å½“å‰æ›´çŸ­ï¼Œåˆ™å…¶ä»–è·¯å¾„å¿…ç„¶ä¼šç»è¿‡å½“å‰æ‰€æœ‰æ¨ªåˆ‡è¾¹ä¸­éé€‰ä¸­çš„æŸæ¡ï¼Œå½“æŸæ¡å·²ç»æ¯”å½“å‰é€‰ä¸­çš„æ›´é•¿äº†ã€‚
<br>
æ‹“æ‰‘æ’åºåˆ™ä¼šè®©æˆ‘ä»¬åœ¨å°†wä½œä¸ºèµ·ç‚¹å‰ï¼Œéå†æ‰€æœ‰æŒ‡å‘wçš„è¾¹ï¼ŒåŠæ­¤æ—¶distTo[w] ä¸€å®šæ˜¯å›ºå®šäº†çš„ï¼Œæˆ‘ä»¬å·²ç»ä»ä»–çš„æ‰€æœ‰å¯èƒ½æ€§ä¸­é€‰å‡ºäº†æœ€çŸ­çš„é‚£ä¸ªã€‚
<br>
æ‹“æ‰‘æ’åºåçš„é¡¶ç‚¹æ”¾æ¾ç®—æ³•ï¼Œå·²ç»æ²¡æœ‰ä»»ä½•æé«˜çš„ç©ºé—´äº†ï¼ˆä¹¦ä¸­æ‰€è¨€ï¼‰ã€‚
<br>

## åŠ æƒæ— ç¯æœ‰å‘å›¾-æ±‚æœ€é•¿è·¯å¾„

<br>
åªéœ€è¦å›¾ä¸­æƒé‡å–ååæ±‚æœ€çŸ­å³å¯ã€‚
<br>

## åŠ æƒæ— ç¯æœ‰å‘å›¾-å¹¶è¡Œä»»åŠ¡è°ƒåº¦

<br>
å‰é¢çš„æ‹“æ‰‘æ’åºï¼Œè§£å†³äº†å•ä¸€å¤„ç†å™¨æƒ…å†µä¸‹çš„ä¼˜å…ˆçº§é™åˆ¶ä»»åŠ¡è°ƒåº¦é—®é¢˜ï¼Œç°å®ä¸­å¾€å¾€æ˜¯å›¢é˜Ÿä½œä¸šï¼Œé‚£ä¹ˆæˆ‘ä»¬æ‰€é¢ä¸´çš„ä¾¿æ˜¯ï¼Œä¼˜å…ˆçº§é™åˆ¶ä¸‹çš„å¹¶è¡Œä»»åŠ¡è°ƒåº¦ã€‚å’‹ä¸€çœ‹ä¸æˆ‘ä»¬çš„æœ‰å‘æ— ç¯å›¾æ²¡æœ‰ä»»ä½•è”ç³»ï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä¹Ÿæ²¡æƒ³åˆ°å°†äºŒè€…ç»“åˆèµ·æ¥çš„é€»è¾‘æŠ½è±¡ï¼‰ã€‚
<br>
ä¹¦ä¸­æåŠï¼Œâ€œå…³é”®è·¯å¾„â€çš„æ–¹æ³•ï¼Œå¯ä»¥è¯æ˜è¯¥é—®é¢˜ä¸æ— ç¯åŠ æƒæœ‰å‘å›¾çš„æ±‚æœ€é•¿è·¯å¾„ç­‰ä»·ï¼š
<br>
ä¼˜å…ˆçº§é™åˆ¶ä¸‹çš„ä»»åŠ¡è°ƒåº¦ï¼Œå¯ä»¥ç®€å•è½¬åŒ–ä¸ºæ— ç¯æœ‰å‘å›¾ï¼Œå¦‚æœå°†æ¯ä¸€ä»»åŠ¡çš„å®Œæˆæ‰€éœ€æ—¶é—´ä½œä¸ºæƒé‡ï¼Œä¾¿æ˜¯æ— ç¯æœ‰å‘åŠ æƒå›¾ï¼Œåœ¨è¿™å¹…å›¾ä¸­ï¼Œé•¿åº¦åˆ™æ˜¯ï¼šå®Œæˆè·¯å¾„æ‰€æœ‰ä»»åŠ¡çš„æœ€æ—©å¯èƒ½æ—¶é—´ã€‚
<br>
å…·ä½“çš„ç”±ä¼˜å…ˆçº§ä»»åŠ¡æ„å»ºæœ‰å‘æ— ç¯å›¾çš„çš„æ­¥éª¤ä¸ç®—æ³•è¯¦è§ã€Šç®—æ³•ã€‹p430ã€‚
<br>
æ‹“å±•ï¼ˆæ²¡ç†è§£ï¼‰ï¼šç›¸å¯¹æœ€åæœŸé™é™åˆ¶ä¸‹çš„å¹¶è¡Œä»»åŠ¡è°ƒåº¦
<br>
aä»»åŠ¡å¿…é¡»è¦åœ¨bä»»åŠ¡å¼€å§‹çš„nä¸ªæ—¶é—´å•ä½å†…å¼€å§‹ï¼Œç­‰ä»·äºï¼Œbä»»åŠ¡å¿…é¡»è¦æ—©äºaä»»åŠ¡nä¸ªæ—¶é—´å†…å¼€å§‹ã€‚
<br>

## ä¸€èˆ¬åŠ æƒæœ‰å‘å›¾ä¸­çš„æœ€çŸ­è·¯å¾„é—®é¢˜

<br>
è¿™é‡Œçš„é™åˆ¶æ¡ä»¶åˆ™æ˜¯ï¼Œæœ‰è´Ÿæ•°æƒé‡ï¼Œå¹¶ä¸”å¯èƒ½å­˜åœ¨ç¯ã€‚djä¸èƒ½å¤„ç†è´Ÿæ•°ï¼Œæ‹“æ‰‘æ’åº&æ¾å¼›ç‚¹æ— æ³•è§£å†³ç¯ã€‚
<br>
å½“å›¾ä¸­å­˜åœ¨è´Ÿæƒé‡æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¸ºäº†ç»è¿‡è´Ÿæƒé‡è€Œç»•å¼¯ï¼Œè¿™ç§æ•ˆåº”éœ€è¦æˆ‘ä»¬å°†æŸ¥æ‰¾æœ€çŸ­è·¯å¾„çš„æ„Ÿè§‰è½¬å˜ä¸ºå¯¹ç®—æ³•æœ¬è´¨çš„ç†è§£ï¼Œéœ€è¦æŠ›å¼ƒç›´è§‰å¹¶åœ¨ä¸€ä¸ªæ›´åŠ æŠ½è±¡çš„å±‚é¢ä¸Šè€ƒè™‘è¿™ä¸ªé—®é¢˜ã€‚
<br>
è´Ÿæƒé‡ç¯
<br>
åœ¨æœ‰å‘åŠ æƒå›¾ä¸­ï¼Œæ‰€æœ‰såˆ°wçš„è·¯å¾„ä¸Šç»è¿‡çš„ç‚¹éƒ½ä¸å­˜åœ¨äºä»»ä½•è´Ÿæƒé‡ç¯æ—¶ï¼Œsåˆ°wçš„æœ€çŸ­è·¯å¾„æ‰æ˜¯å­˜åœ¨çš„ã€‚
<br>
ä¸‹é¢å…ˆç»™ä¸€äº›çº¦æŸï¼Œä»¥å‡è½»ç®—æ³•çš„å¤æ‚åº¦ã€‚
<br>
1.èµ·ç‚¹ä¸å¯è¾¾çš„é¡¶ç‚¹ï¼Œæœ€çŸ­è·¯å¾„ä¸ºæ­£æ— ç©·ã€‚
<br>
2.èµ·ç‚¹å¯è¾¾ï¼Œä½†è·¯å¾„ä¸ŠæŸä¸ªé¡¶ç‚¹å±äºè´Ÿæƒé‡ç¯ï¼Œåˆ™æœ€çŸ­è·¯å¾„ä¸ºè´Ÿæ— ç©·ã€‚
<br>
3.å¯¹äºå…¶ä»–æ‰€æœ‰é¡¶ç‚¹ï¼Œè®¡ç®—æœ€çŸ­è·¯å¾„æ ‘&æƒé‡ã€‚
<br>
ç°åœ¨éœ€è¦æˆ‘ä»¬è§£å†³çš„é—®é¢˜è½¬åŒ–ä¸ºï¼š
<br>
1.è´Ÿæƒé‡ç¯çš„æ£€æµ‹
<br>
2.è´Ÿæƒé‡ç¯ä¸å¯è¾¾æ—¶çš„å•ç‚¹æœ€çŸ­è·¯å¾„
<br>
bellman-fordç®—æ³•çš„ç†è®ºè¯æ˜ï¼Œæ²¡çœ‹æ‡‚...
<br>
å¯¹äºæ²¡çœ‹æ‡‚çš„ä¸œè¥¿ï¼Œå¤„ç†èµ·æ¥æ€»æ˜¯å¾ˆä¸ç”˜å¿ƒçš„ï¼Œå°±åƒæ˜¯åœ¨åšä¸€ç§æ— ç”¨åŠŸï¼Œä¼¼ä¹æ›¾ç»å¹²è¿‡æŸäº‹ï¼Œå¦‚æ­¤è¿™èˆ¬ã€‚
<br>
ä¸èƒ½æè¿°å…¶è¯æ˜ï¼Œä¸ºä»€ä¹ˆä¹ˆè¿™æ ·åšæ˜¯å¯¹çš„ï¼Œåªèƒ½æè¿°ä¸€ä¸‹ç®—æ³•æœ¬èº«ï¼Œä¹Ÿè§‰å¾—æ²¡æœ‰ä½™åŠ›ç»§ç»­æ·±å…¥ä¸‹å»äº†ã€‚
<br>
å½“æˆ‘ä»¬ï¼Œæ”¹å˜äº†æŸä¸€ä¸ªç‚¹çš„distToå€¼ï¼Œä»è¿™ä¸ªç‚¹æŒ‡å‡ºçš„å…¶ä»–ç›¸å…³ç‚¹çš„distTo éƒ½ä¼šæ”¶åˆ°å½±å“ï¼Œéœ€è¦é‡æ–°åˆ¤æ–­ã€‚æ•…æˆ‘ä»¬æ˜¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è¾…åŠ©ï¼Œå¯¹wç‚¹çš„distToåšä¿®æ”¹æ—¶ï¼Œå°†å—å…¶å½±å“çš„æ‰€æœ‰ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼ˆå¦‚æœè¯¥ç‚¹é˜Ÿåˆ—ä¸­å·²ç»å­˜åœ¨åˆ™å¿½ç•¥ï¼‰åªè¦é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œä¸”ä¸å­˜åœ¨è´Ÿæƒé‡ç¯ï¼Œå°±ä¸€ç›´ä¸åœçš„ä»é˜Ÿåˆ—ä¸­å–ç‚¹relaxã€‚
<br>
æ²¡çœ‹æ‡‚ï¼ŒæŒ–ä¸ªå‘ï¼Œåé¢åŸ‹ã€‚
<br>

```java

```

<br>
20240116:ä¸æƒ³åŸ‹ï¼Œç›´æ¥å¼€å§‹å­—ç¬¦ä¸²éƒ¨åˆ†å§ã€‚
<br>

### 

